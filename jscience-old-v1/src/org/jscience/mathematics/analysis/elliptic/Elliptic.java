// JTEM - Java Tools for Experimental Mathematics
// Copyright (C) 2001 JTEM-Group
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package org.jscience.mathematics.analysis.elliptic;

import org.jscience.mathematics.algebraic.numbers.Complex;


/**
 * Class provides Jacobi's elliptic theta functions.
 *
 * @author Markus Schmies, Boris Springborn
 * @version 0.5
 */

public class Elliptic {

    static final double EPS = 1e-12;

    Elliptic() {
    }

    final static Complex ZERO = new Complex(0);

    /**
     * Computes theta constants c0 = &theta;<sub>0</sub>(0,&tau;), c1 = &theta;<sub>1</sub>(0,&tau;) = 0,
     * c2 = &theta;<sub>2</sub>(0,&tau;) = 0, and c3 = &theta;<sub>3</sub>(0,&tau;).
     * The result is stored in the array c.
     * The array may have null entries, which causes the routine to create
     * instances.
     *
     * @param tau lattice paramter &tau;
     * @param eps absoute error for theta functions
     * @param c   array with the four theta constants (on output)
     */
    static void thetaConstants(final Complex tau,
                               final double eps,
                               final Complex[] c) {
        if (c.length != 4) {
            throw new IllegalArgumentException("there are four constants");
        }

        for (int i = 0; i < 4; i++) {
            if (c[i] == null) {
                c[i] = Complex.ZERO;

            }
        }
        c[1] = Complex.ZERO;

        theta4(ZERO, tau, eps, c[0]);
        theta2(ZERO, tau, eps, c[2]);
        theta3(ZERO, tau, eps, c[3]);
    }

    /**
     * Computes theta constants &theta;<sub>0</sub>(0,&tau;), &theta;<sub>1</sub>(0,&tau;) = 0,
     * &theta;<sub>2</sub>(0,&tau;) = 0, and &theta;<sub>3</sub>(0,&tau;).
     * The result is stored in the array c.
     * The array may have null entries, which causes the routine to create
     * instances.
     *
     * @param tau lattice paramter &tau;
     * @param eps absoute error for theta functions
     * @param c   array with the four theta constants (on output)
     */
    public static void thetaConstants(final Complex tau,
                                      final Complex[] c) {
        if (c.length != 4) {
            throw new IllegalArgumentException("there are four constants");
        }

        for (int i = 0; i < 4; i++) {
            if (c[i] == null) {
                c[i] = Complex.ZERO;

            }
        }
        c[1] = Complex.ZERO;

        theta4(ZERO, tau, EPS, c[0]);
        theta2(ZERO, tau, EPS, c[2]);
        theta3(ZERO, tau, EPS, c[3]);
    }

    /**
     * Returns theta constants &theta;<sub>0</sub>(0,&tau;), &theta;<sub>1</sub>(0,&tau;) = 0,
     * &theta;<sub>2</sub>(0,&tau;) = 0, and &theta;<sub>3</sub>(0,&tau;).
     * The result is stored in the array c.
     * The array may have null entries, which causes the routine to create
     * instances.
     *
     * @param tau lattice paramter &tau;
     * @param eps absoute error for theta functions
     * @return array with the four theta constants (on output)
     */
    static Complex[] thetaConstants(final Complex tau,
                                    final double eps) {
        Complex[] c = new Complex[4];
        thetaConstants(tau, eps, c);
        return c;
    }

    /**
     * Returns theta constants &theta;<sub>0</sub>(0,&tau;), &theta;<sub>1</sub>(0,&tau;) = 0,
     * &theta;<sub>2</sub>(0,&tau;) = 0, and &theta;<sub>3</sub>(0,&tau;).
     * The result is stored in the array c.
     * The array may have null entries, which causes the routine to create
     * instances.
     *
     * @param tau lattice paramter &tau;
     * @return array with the four theta constants (on output)
     */
    public static Complex[] thetaConstants(final Complex tau) {
        Complex[] c = new Complex[4];
        thetaConstants(tau, EPS, c);
        return c;
    }

    /**
     * Computes for given w and &tau; a representetive in
     * the lattice generated by 1 and &tau; such that w = z + m &pi; + n &pi; &tau;
     * and z = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5.
     * c is the quasi-periodic factor which gives:
     * &theta;<sub>3</sub>(w,&tau;) = c(z,&tau;,n) &theta;<sub>3</sub>(z,&tau;)
     * w and z may coinside.
     *
     * @param w   argument
     * @param tau lattice parameter
     * @param z   = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5
     * @return period integer for &tau;
     */
    static int transformIntoFundamental(final Complex w, final Complex tau,
                                        final Complex z) {

        final double Y = (w.imag()) / tau.imag() / Math.PI; // Y = y+n;
        final double X = w.real() / Math.PI - Y * tau.real(); // X = x+m;

        final int m = (int) (Math.floor(X + 0.5));
        final int n = (int) (Math.floor(Y + 0.5));

        transform(w, tau, -m, -n, z);

        return n;
    }

    /**
     * Computes w = z + m &pi; + n &pi; &tau;
     * w and z may coinside.
     */
    static void transform(final Complex z, final Complex tau,
                          final int m, final int n,
                          Complex w) {
        w = new Complex(z.real() + (m + n * tau.real()) * Math.PI, z.imag() + (n * tau.imag()) * Math.PI);
    }

    /**
     * Computes w = z + x &pi; + y &pi; &tau;
     */
    static void transform(final Complex z, final Complex tau,
                          final double x, final double y,
                          Complex w) {
        w = new Complex(z.real() + (x + y * tau.real()) * Math.PI, z.imag() + (y * tau.imag()) * Math.PI);
    }

    /**
     * Computes integer N such that:
     * <p/>
     * | exp ( i &pi; &tau; N*N ) cos( 2NZ ) | < eps
     * <p/>
     * the term above can be used to estimate the error
     * of theta[34].
     *
     * @param z
     * @param tau
     * @param eps
     * @return N
     */
    static int lengthOfSeries(final Complex z, final Complex tau,
                              final double eps) {

        final double delta = -Math.PI * tau.imag();
        final double y = Math.abs(z.imag());

        return (int) Math.floor(1 -
                (y + Math.sqrt(Math.log(eps) * delta + y * y)) /
                        delta);
    }

    /**
     * Periodicity factor for theta functions: c = exp (-i n (n &pi; &tau; + 2 z ) )
     * <p/>
     * theta[1234](w,&tau;) = (+/-) c(z,&tau;,n) &theta;<sub>4</sub>(z,&tau;)
     * with w = z + m &pi; + n &pi; &tau;.
     * Sign depends on theta function and on n and/or m.
     *
     * @param z
     * @param tau
     * @param n
     * @param logOfC log(c)
     */
    static void logOfPeriodicityFactor(final Complex z, final Complex tau,
                                       final int n,
                                       Complex logOfC) {

        logOfC = new Complex(-n * (n * Math.PI * tau.real() + 2 * z.real()),
                -n * (n * Math.PI * tau.imag() + 2 * z.imag()));
        logOfC = new Complex(-logOfC.imag(), logOfC.real());
    }

    static void logOfShiftFactor(final Complex z, final Complex tau,
                                 Complex logOfD) {
        logOfD = new Complex(Math.PI / 4 * tau.real() + z.real(), Math.PI / 4 * tau.imag() + z.imag());
        logOfD = new Complex(-logOfD.imag(), logOfD.real());
    }

    static Complex logOfShiftFactor(final Complex z, Complex tau) {
        Complex logOfD = Complex.ZERO;
        logOfShiftFactor(z, tau, logOfD);
        return logOfD;
    }

    /* **** THETA **** */

    /**
     * Computes &theta;(z,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function, thus
     * {@link #theta(Complex,Complex)} ,
     * {@link #theta0(Complex,Complex)}, and
     * {@link #theta4(Complex,Complex)}
     * are identical.
     *
     * @param z   argument
     * @param tau lattice parameter
     * @return &theta;(z,&tau;)
     * @see #theta(Complex,Complex,Complex,Complex,Complex)
     */
    public static Complex theta(final Complex z, final Complex tau) {
        return theta4(z, tau);
    }

    /**
     * Helps to compute &theta;(w,&tau;) = c &theta;(z,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function, thus
     * {@link #theta(Complex,Complex,Complex,Complex,Complex)},
     * {@link #theta0(Complex,Complex,Complex,Complex,Complex)}, and
     * {@link #theta4(Complex,Complex,Complex,Complex,Complex)}
     * are idenical.
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param z        = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta(Complex,Complex)
     */
    public static void theta(final Complex w, final Complex tau,
                             final Complex z,
                             final Complex logOfC,
                             final Complex thetaOfZ) {
        theta4(w, tau, EPS, z, logOfC, thetaOfZ);
    }

    /* **** THETA0 **** */

    /**
     * Computes &theta;<sub>0</sub>(z,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function, thus
     * {@link #theta(Complex,Complex)},
     * {@link #theta0(Complex,Complex)}, and
     * {@link #theta4(Complex,Complex)}
     * are identical.
     *
     * @param z   argument
     * @param tau lattice parameter
     * @return &theta;<sub>0</sub>(z,&tau;)
     * @see #theta0(Complex,Complex,Complex,Complex,Complex)
     */
    public static Complex theta0(final Complex z, final Complex tau) {
        return theta4(z, tau);
    }

    /**
     * Helps to compute &theta;<sub>0</sub>(w,&tau;) = c &theta;(z,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function, thus
     * {@link #theta(Complex,Complex,Complex,Complex,Complex)},
     * {@link #theta0(Complex,Complex,Complex,Complex,Complex)}, and
     * {@link #theta4(Complex,Complex,Complex,Complex,Complex)}
     * are identical.
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param z        = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta0(Complex,Complex)
     */
    public static void theta0(final Complex w, final Complex tau,
                              final Complex z,
                              final Complex logOfC,
                              final Complex thetaOfZ) {
        theta4(w, tau, EPS, z, logOfC, thetaOfZ);
    }

    /**
     * ***  THETA 1 *******
     */

    static void logOfPeriodicityFactorForTheta1(final Complex z,
                                                final Complex tau,
                                                final int m, final int n,
                                                Complex logOfC) {

        logOfPeriodicityFactor(z, tau, n, logOfC);

        logOfC = new Complex(logOfC.real(), logOfC.imag() + (m + n) % 2 * Math.PI);

    }

    static void periodicityFactorForTheta1(final Complex z, final Complex tau,
                                           final int m, final int n,
                                           Complex result) {
        logOfPeriodicityFactorForTheta1(z, tau, m, n, result);
        result = Complex.exp(result);
    }

    /**
     * Returns quasi-periodic factor.
     * <p/>
     * &theta;<sub>1</sub>(w,&tau;) = c(z,&tau;,m,n) &theta;<sub>1</sub>(z,&tau;)
     * with w = z + m &pi; + n &pi; &tau;.
     *
     * @return c
     */
    static Complex periodicityFactorForTheta1(final Complex z, final Complex tau,
                                              final int m, final int n) {
        Complex result = Complex.ZERO;
        periodicityFactorForTheta1(z, tau, m, n, result);
        return result;
    }

    static Complex theta1(final Complex z, final Complex tau,
                          final double eps) {
        final Complex result = Complex.ZERO;
        theta1(z, tau, eps, result);
        return result;
    }

    /**
     * Computes &theta;<sub>1</sub>(z,&tau;).
     *
     * @param z   argument
     * @param tau lattice parameter
     * @return &theta;<sub>1</sub>(z,&tau;)
     * @see #theta1(Complex,Complex,Complex,Complex,Complex)
     */
    public static Complex theta1(final Complex z, final Complex tau) {
        final Complex result = Complex.ZERO;
        theta1(z, tau, EPS, result);
        return result;
    }

    static void theta1(final Complex z, final Complex tau,
                       final Complex theta1OfZ) {
        theta1(z, tau, EPS, theta1OfZ);
    }

    /**
     * Helps to compute &theta;<sub>1</sub>(w,&tau;) = c &theta;(z,&tau;).
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param z        equals x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta1(Complex,Complex)
     */
    public static void theta1(final Complex w, final Complex tau,
                              final Complex z,
                              final Complex logOfC,
                              final Complex thetaOfZ) {
        theta1(w, tau, EPS, z, logOfC, thetaOfZ);
    }

    /**
     * Helps to compute &theta;<sub>1</sub>(w,&tau;) = c &theta;(z,&tau;).
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param z        equals x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta1(Complex,Complex)
     */
    static void theta1(final Complex z, final Complex tau,
                       final double eps, Complex thetaOfZ) {

        Complex logOfC = Complex.ZERO;

        theta1(z, tau, eps, Complex.ZERO, logOfC, thetaOfZ);

        logOfC = Complex.exp(logOfC);

        thetaOfZ = thetaOfZ.multiply(logOfC);
    }

    /**
     * Helps to compute &theta;<sub>1</sub>(w,&tau;) = c &theta;(z,&tau;).
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param eps      abs error for theta4OfZ
     * @param z        equals x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta1(Complex,Complex)
     */
    static void theta1(final Complex w, final Complex tau,
                       final double eps,
                       final Complex z,
                       Complex logOfC,
                       final Complex thetaOfZ) {

        transform(w, tau, 0.0, 0.5, z);

        theta4(z, tau, eps, z, logOfC, thetaOfZ);

        Complex logOfD = logOfShiftFactor(w, tau);

        logOfD = new Complex(logOfD.real(), logOfD.imag() - 0.5 * Math.PI);

        logOfC = logOfC.add(logOfD);
    }

    /**
     * ***  THETA 2 *******
     */

    static void logOfPeriodicityFactorForTheta2(final Complex z,
                                                final Complex tau,
                                                final int m, final int n,
                                                Complex logOfC) {

        logOfPeriodicityFactor(z, tau, n, logOfC);

        logOfC = new Complex(logOfC.real(), logOfC.imag() + m % 2 * Math.PI);

    }

    static void periodicityFactorForTheta2(final Complex z, final Complex tau,
                                           final int m, final int n,
                                           Complex result) {
        logOfPeriodicityFactorForTheta2(z, tau, m, n, result);
        result = Complex.exp(result);
    }

    /**
     * Returns quasi-periodic factor.
     * <p/>
     * &theta;<sub>2</sub>(w,&tau;) = c(z,&tau;,m,n) &theta;<sub>2</sub>(z,&tau;)
     * with w = z + m &pi; + n &pi; &tau;.
     *
     * @return c
     */
    static Complex periodicityFactorForTheta2(final Complex z, final Complex tau,
                                              final int m, final int n) {
        Complex result = Complex.ZERO;
        periodicityFactorForTheta2(z, tau, m, n, result);
        return result;
    }

    static Complex theta2(final Complex z, final Complex tau,
                          final double eps) {
        final Complex result = Complex.ZERO;
        theta2(z, tau, eps, result);
        return result;
    }


    /**
     * Computes &theta;<sub>2</sub>(z,&tau;).
     *
     * @param z   argument
     * @param tau lattice parameter
     * @return &theta;<sub>2</sub>(z,&tau;)
     * @see #theta2(Complex,Complex,Complex,Complex,Complex)
     */
    public static Complex theta2(final Complex z, final Complex tau) {
        final Complex result = Complex.ZERO;
        theta2(z, tau, EPS, result);
        return result;
    }

    static void theta2(final Complex z, final Complex tau,
                       final Complex theta2OfZ) {
        theta2(z, tau, EPS, theta2OfZ);
    }


    /**
     * Helps to compute &theta;<sub>2</sub>(w,&tau;) = c &theta;(z,&tau;).
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param z        equals x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta2(Complex,Complex)
     */
    public static void theta2(final Complex w, final Complex tau,
                              final Complex z,
                              final Complex logOfC,
                              final Complex thetaOfZ) {
        theta2(w, tau, EPS, z, logOfC, thetaOfZ);
    }

    static void theta2(final Complex z, final Complex tau,
                       final double eps, Complex thetaOfZ) {

        Complex logOfC = Complex.ZERO;

        theta2(z, tau, eps, Complex.ZERO, logOfC, thetaOfZ);

        logOfC = Complex.exp(logOfC);

        thetaOfZ = thetaOfZ.multiply(logOfC);
    }

    /**
     * Helps to compute &theta;<sub>2</sub>(w,&tau;) = c &theta;<sub>4</sub>(z,&tau;).
     *
     * @param w
     * @param tau
     * @param eps       abs error for &theta;<sub>4</sub>OfZ
     * @param z         = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5
     * @param logOfC    = log(c)
     * @param theta4OfZ = &theta;(z,&tau;)
     */
    static void theta2(final Complex w, final Complex tau,
                       final double eps,
                       final Complex z,
                       Complex logOfC,
                       final Complex thetaOfZ) {

        transform(w, tau, 0.5, 0.5, z);

        theta4(z, tau, eps, z, logOfC, thetaOfZ);

        Complex logOfD = logOfShiftFactor(w, tau);

        logOfC = logOfC.add(logOfD);
    }

    /**
     * ***  THETA 3 *******
     */

    static void logOfPeriodicityFactorForTheta3(final Complex z,
                                                final Complex tau,
                                                final int n,
                                                final Complex logOfC) {

        logOfPeriodicityFactor(z, tau, n, logOfC);
    }

    static void periodicityFactorForTheta3(final Complex z, final Complex tau,
                                           final int n,
                                           Complex result) {
        logOfPeriodicityFactorForTheta3(z, tau, n, result);
        result = Complex.exp(result);
    }

    /**
     * Returns quasi-periodic factor.
     * <p/>
     * &theta;<sub>3</sub>(w,&tau;) = c(z,&tau;,n) &theta;<sub>3</sub>(z,&tau;)
     * with w = z + m &pi; + n &pi; &tau;.
     *
     * @return c
     */
    static Complex periodicityFactorForTheta3(final Complex z, final Complex tau,
                                              final int n) {
        Complex result = Complex.ZERO;
        periodicityFactorForTheta3(z, tau, n, result);
        return result;
    }

    static Complex theta3(final Complex z, final Complex tau,
                          final double eps) {
        final Complex result = Complex.ZERO;
        theta3(z, tau, eps, result);
        return result;
    }

    /**
     * Computes &theta;<sub>3</sub>(z,&tau;).
     *
     * @param z   argument
     * @param tau lattice parameter
     * @return &theta;<sub>3</sub>(z,&tau;)
     * @see #theta3(Complex,Complex,Complex,Complex,Complex)
     */
    public static Complex theta3(final Complex z, final Complex tau) {
        final Complex result = Complex.ZERO;
        theta3(z, tau, EPS, result);
        return result;
    }

    static void theta3(final Complex z, final Complex tau,
                       final Complex theta3OfZ) {
        theta3(z, tau, EPS, theta3OfZ);
    }

    static void theta3(final Complex z, final Complex tau,
                       final double eps, Complex theta3OfZ) {

        Complex logOfC = Complex.ZERO;

        theta3(z, tau, eps, Complex.ZERO, logOfC, theta3OfZ);

        logOfC = Complex.exp(logOfC);

        theta3OfZ = theta3OfZ.multiply(logOfC);
    }

    /**
     * Helps to compute &theta;<sub>3</sub>(w,&tau;) = c &theta;(z,&tau;).
     *
     * @param w        argument
     * @param tau      lattice parameter
     * @param z        equals x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     * @see #theta3(Complex,Complex)
     */
    public static void theta3(final Complex w, final Complex tau,
                              final Complex z,
                              final Complex logOfC,
                              final Complex thetaOfZ) {
        theta3(w, tau, EPS, z, logOfC, thetaOfZ);
    }

    /**
     * Helps to compute &theta;<sub>3</sub>(w,&tau;) = c &theta;<sub>4</sub>(z,&tau;).
     *
     * @param w
     * @param tau
     * @param eps       abs error for theta4OfZ
     * @param z         = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5
     * @param logOfC    =log(c)
     * @param theta4OfZ = &theta;<sub>4</sub>(z,&tau;)
     */
    static void theta3(final Complex w, final Complex tau,
                       final double eps,
                       final Complex z,
                       final Complex logOfC,
                       final Complex thetaOfZ) {

        transform(w, tau, 0.5, 0, z);

        theta4(z, tau, eps, z, logOfC, thetaOfZ);
    }

    /* *****  THETA4 ******* */

    static void logOfPeriodicityFactorForTheta4
            (final Complex z, final Complex tau,
             final int n,
             Complex logOfC) {

        logOfPeriodicityFactor(z, tau, n, logOfC);

        logOfC = new Complex(logOfC.real(), logOfC.imag() + (n % 2) * Math.PI);
    }

    static void periodicityFactorForTheta4
            (final Complex z, final Complex tau,
             final int n,
             Complex result) {
        logOfPeriodicityFactorForTheta4(z, tau, n, result);
        result = Complex.exp(result);
    }

    /**
     * Returns quasi-periodic factor.
     * <p/>
     * &theta;<sub>4</sub>(w,&tau;) = c(z,&tau;,n) &theta;(z,&tau;)
     * with w = z + m &pi; + n &pi; &tau;.
     *
     * @return c
     */
    static Complex periodicityFactorForTheta4(final Complex z, final Complex tau,
                                              final int n) {
        Complex result = Complex.ZERO;
        periodicityFactorForTheta4(z, tau, n, result);
        return result;
    }

    static Complex theta4(final Complex z, final Complex tau,
                          final double eps) {
        final Complex result = Complex.ZERO;
        theta4(z, tau, eps, result);
        return result;
    }

    static void theta4(final Complex z, final Complex tau,
                       final Complex theta4OfZ) {
        theta4(z, tau, EPS, theta4OfZ);
    }

    static void theta4(final Complex z, final Complex tau,
                       final double eps, Complex theta4OfZ) {

        Complex logOfC = Complex.ZERO;

        theta4(z, tau, eps, Complex.ZERO, logOfC, theta4OfZ);

        logOfC = Complex.exp(logOfC);

        theta4OfZ = theta4OfZ.multiply(logOfC);
    }

    /**
     * Computes &theta;<sub>4</sub>(w,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function, thus
     * {@link #theta(Complex,Complex)},
     * {@link #theta0(Complex,Complex)}, and
     * {@link #theta4(Complex,Complex)}
     * are identical.
     *
     * @param z   argument
     * @param tau lattice parameter
     * @see #theta4(Complex,Complex,Complex,Complex,Complex)
     */
    public static Complex theta4(final Complex z, final Complex tau) {
        final Complex result = Complex.ZERO;
        theta4(z, tau, EPS, result);
        return result;
    }

    /**
     * Helps to compute &theta;<sub>4</sub>(w,&tau;) = c &theta;(z,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function, thus
     * {@link #theta(Complex,Complex,Complex,Complex,Complex)},
     * {@link #theta0(Complex,Complex,Complex,Complex,Complex)}, and
     * {@link #theta4(Complex,Complex,Complex,Complex,Complex)}
     * are identical.
     *
     * @param w         argument
     * @param tau       lattice parameter
     * @param z         = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC    =log(c) (on output)
     * @param theta3OfZ = &theta;<sub>4</sub>(z,&tau;) (on output)
     * @see #theta4(Complex,Complex)
     */
    public static void theta4(final Complex w, final Complex tau,
                              final Complex z,
                              final Complex logOfC,
                              final Complex thetaOfZ) {
        theta4(w, tau, EPS, z, logOfC, thetaOfZ);
    }

    /**
     * Helps to compute &theta;<sub>4</sub>(w,&tau;) = c &theta;(z,&tau;).
     * &theta;, &theta;<sub>0</sub>, &theta;<sub>4</sub> refer to the same function.
     *
     * @param w        argument
     * @param tau      lattice paramter &tau;
     * @param eps      abs error for thetaOfZ
     * @param z        = x &pi; + y &pi; &tau; with -0.5 <= x,y <= 0.5 (on output)
     * @param logOfC   equals log(c) (on output)
     * @param thetaOfZ equals &theta;(z,&tau;) (on output)
     */
    static void theta4(final Complex w, final Complex tau,
                       final double eps,
                       final Complex z,
                       final Complex logOfC,
                       final Complex thetaOfZ) {

        final int n = transformIntoFundamental(w, tau, z);
        logOfPeriodicityFactorForTheta4(z, tau, n, logOfC);
        theta4PlainSeries(z, tau, eps, thetaOfZ);
    }

    static void theta4PlainSeries(final Complex z, final Complex tau,
                                  final double eps, Complex result) {

        if (!(tau.imag() > 0)) {
            throw new IllegalArgumentException(
                    "imagiary part of tau must be positive");
        }

        final Complex tauIPi = tau.multiply(new Complex(0, Math.PI));

        Complex tauIPiNSqr = Complex.ZERO;

        final Complex iz = new Complex(-z.imag(), z.real());

        Complex iZ2N = Complex.ZERO;
        Complex term = Complex.ZERO;
        Complex term1 = Complex.ZERO;
        Complex term2 = Complex.ZERO;

        final int N = lengthOfSeries(z, tau, eps);

        double sign = -1;

        result = Complex.ONE;

        for (int n = 1; n <= N; n++, sign *= -1) {

            iZ2N = iz.multiply(2 * n);

            tauIPiNSqr = tauIPi.multiply(n * n);

            term1 = tauIPiNSqr.add(iZ2N);
            term1 = Complex.exp(term1);

            term2 = tauIPiNSqr.subtract(iZ2N);
            term2 = Complex.exp(term2);

            term = term1.add(term2);
            term = term.multiply(sign);

            result = result.add(term);
        }
    }

}
