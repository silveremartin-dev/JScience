/*
 * JScience - Java(TM) Tools and Libraries for the Advancement of Sciences.
 * Copyright (C) 2025-2026 - Silvere Martin-Michiellot and Gemini AI (Google DeepMind)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.jscience.mathematics.geometry;

import org.jscience.mathematics.analysis.polynomials.DoublePolynomial;
import org.jscience.util.FatalException;

import java.io.PrintWriter;
import java.util.Vector;

/**
 * ï¿½Rï¿½ï¿½ï¿½ï¿½ : ï¿½~ï¿½ï¿½ï¿½Ê‚ï¿½\ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½X?B
 * <p/>
 * ï¿½~ï¿½ï¿½ï¿½Ê‚ï¿½?Aï¿½ï¿½ï¿½Ì’ï¿½?Sï¿½ÌˆÊ’uï¿½Æ‹ï¿½?ï¿½ X/Y/Z ï¿½ï¿½ï¿½Ì•ï¿½ï¿½î¦‚ï¿½ï¿½ï¿½?ï¿½?Wï¿½n
 * (ï¿½zï¿½u?ï¿½ï¿½?A{@link Axis2Placement3D Axis2Placement3D}) position ï¿½ï¿½
 * ï¿½ï¿½ï¿½a radius ï¿½Å’ï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½?B
 * </p>
 * <p/>
 * ï¿½~ï¿½ï¿½ï¿½Ê‚ï¿½
 * U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½Í—Lï¿½ÅŽï¿½ï¿½Iï¿½Å‚ï¿½ï¿½ï¿½?A
 * ï¿½ï¿½ï¿½Ìƒvï¿½ï¿½ï¿½Cï¿½}ï¿½ï¿½ï¿½È—Lï¿½ï¿½ï¿½Ô‚ï¿½ [0, (2 * ï¿½ï¿½)] ï¿½Å‚ï¿½ï¿½ï¿½?B
 * V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½Í–ï¿½ï¿½Å”ï¿½ï¿½ï¿½Iï¿½Å‚ï¿½ï¿½ï¿½?B
 * </p>
 * <p/>
 * (u, v) ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Æ‚ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½ï¿½ P(u, v) ï¿½Ìƒpï¿½ï¿½ï¿½?ï¿½gï¿½ï¿½ï¿½bï¿½Nï¿½\ï¿½ï¿½ï¿½ï¿½?Aï¿½È‰ï¿½ï¿½Ì’Ê‚ï¿½?B
 * <pre>
 * 	P(u, v) = c + radius * (cos(u) * x + sin(u) * y) + v * z
 * </pre>
 * ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?Ac, x, y, z ï¿½Í‚ï¿½ï¿½ê‚¼ï¿½ï¿½
 * <pre>
 * 	c : position.location()
 * 	x : position.x()
 * 	y : position.y()
 * 	z : position.z()
 * </pre>
 * ï¿½ï¿½\ï¿½ï¿½?B
 * </p>
 *
 * @author Information-technology Promotion Agency, Japan
 * @version $Revision: 1.5 $, $Date: 2006/05/20 23:25:41 $
 */

public class CylindricalSurface3D extends ElementarySurface3D {
    /**
     * ï¿½ï¿½ï¿½a?B
     *
     * @serial
     */
    private double radius;

    /**
     * ï¿½ï¿½ï¿½aï¿½ï¿½?Ý’è‚·ï¿½ï¿½?B
     * <p/>
     * radius ï¿½Ì’lï¿½ï¿½?A
     * ï¿½ï¿½?ï¿½?Ý’è‚³ï¿½ï¿½Ä‚ï¿½ï¿½é‰‰ï¿½Z?ï¿½?ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½
     * InvalidArgumentValueException	ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param radius ï¿½ï¿½ï¿½a
     * @see InvalidArgumentValueException
     */
    private void setRadius(double radius) {
        ConditionOfOperation condition =
                ConditionOfOperation.getCondition();
        double dTol = condition.getToleranceForDistance();

        if (radius < dTol) {
            throw new InvalidArgumentValueException();
        }
        this.radius = radius;
    }

    /**
     * ï¿½ï¿½?ï¿½?Wï¿½nï¿½Æ”ï¿½ï¿½aï¿½ï¿½^ï¿½ï¿½ï¿½ÄƒIï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½?\ï¿½zï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * position ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * InvalidArgumentValueException ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * radius ï¿½Ì’lï¿½ï¿½?A
     * ï¿½ï¿½?ï¿½?Ý’è‚³ï¿½ï¿½Ä‚ï¿½ï¿½é‰‰ï¿½Z?ï¿½?ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½
     * InvalidArgumentValueException	ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param position ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½_ï¿½Æ‹ï¿½?ï¿½ X/Y/Z ï¿½ï¿½ï¿½Ì•ï¿½ï¿½î¦‚ï¿½ï¿½ï¿½?ï¿½?Wï¿½n
     * @param radius   ï¿½ï¿½ï¿½a
     * @see InvalidArgumentValueException
     */
    public CylindricalSurface3D(Axis2Placement3D position,
                                double radius) {
        super(position);
        setRadius(radius);
    }

    /**
     * ï¿½ï¿½?Sï¿½ï¿½ï¿½Æ”ï¿½ï¿½aï¿½ï¿½^ï¿½ï¿½ï¿½ÄƒIï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½?\ï¿½zï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * cntr ï¿½Âµï¿½ï¿½ï¿½ï¿½ axis ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * InvalidArgumentValueException ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * radius ï¿½Ì’lï¿½ï¿½?A
     * ï¿½ï¿½?ï¿½?Ý’è‚³ï¿½ï¿½Ä‚ï¿½ï¿½é‰‰ï¿½Z?ï¿½?ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½
     * InvalidArgumentValueException	ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param cntr   ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½_
     * @param axis   ï¿½ï¿½?ï¿½ Z ï¿½ï¿½ï¿½ï¿½ï¿½
     * @param radius ï¿½ï¿½ï¿½a
     * @see InvalidArgumentValueException
     */
    public CylindricalSurface3D(Point3D cntr, Vector3D axis,
                                double radius) {
        super(new Axis2Placement3D(cntr, axis,
                axis.verticalVector().unitized()));
        setRadius(radius);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚Ì”ï¿½ï¿½aï¿½ï¿½Ô‚ï¿½?B
     *
     * @return ï¿½ï¿½ï¿½a
     */
    public double radius() {
        return this.radius;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ï¿½?Wï¿½lï¿½ï¿½Ô‚ï¿½?B
     *
     * @param uParam U ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?Wï¿½l
     */
    public Point3D coordinates(double uParam, double vParam) {
        CartesianTransformationOperator3D gtrans = toGlobal();
        double x = radius * Math.cos(uParam);
        double y = radius * Math.sin(uParam);
        Point3D pnt = new CartesianPoint3D(x, y, vParam);

        return gtrans.transform(pnt);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½ï¿½ï¿½Å‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Æ‚ï¿½?Aï¿½pï¿½ï¿½ï¿½??[ï¿½^ U/V ï¿½ÌŠe?Xï¿½É‚Â‚ï¿½ï¿½Ä‚ÌˆêŽŸï¿½Î“ï¿½ï¿½ï¿½?ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½zï¿½ï¿½Ì—vï¿½f?ï¿½ï¿½ï¿½ 2 ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½zï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½Ì—vï¿½fï¿½É‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½?A
     * ï¿½ï¿½Ô–Ú‚Ì—vï¿½fï¿½É‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ü‚ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Ì”zï¿½ï¿½
     */
    public Vector3D[] tangentVector(double uParam, double vParam) {
        CartesianTransformationOperator3D gtrans = toGlobal();
        double dux = -radius * Math.sin(uParam);
        double duy = radius * Math.cos(uParam);
        Vector3D dup = new LiteralVector3D(dux, duy, 0.0);
        Vector3D dvp = Vector3D.zUnitVector;

        Vector3D[] tang = {gtrans.transform(dup), gtrans.transform(dvp)};
        return tang;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì–@?ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½ï¿½ï¿½Ô‚ï¿½ï¿½@?ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½?A?ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½Pï¿½Êƒxï¿½Nï¿½gï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½@?ï¿½xï¿½Nï¿½gï¿½ï¿½
     */
    public Vector3D normalVector(double uParam, double vParam) {
        CartesianTransformationOperator3D gtrans = toGlobal();
        double x = radius * Math.cos(uParam);
        double y = radius * Math.sin(uParam);
        Vector3D nrm = new LiteralVector3D(x, y, 0.0);

        return gtrans.transform(nrm).unitized();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ÌŽï¿½È—ï¿½?ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½È—ï¿½1 (principalCurvature1) ï¿½É‚ï¿½ (- 1 / radius)?A
     * ï¿½ï¿½È—ï¿½2 (principalCurvature2) ï¿½É‚ï¿½ 0?A
     * ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½1 (principalDirection1) ï¿½É‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Ì’Pï¿½Êƒxï¿½Nï¿½gï¿½ï¿½?A
     * ï¿½ï¿½ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½2 (principalDirection2) ï¿½É‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Ì’Pï¿½Êƒxï¿½Nï¿½gï¿½ï¿½
     * ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½ï¿½È—ï¿½?ï¿½ï¿½
     */
    public SurfaceCurvature3D curvature(double uParam, double vParam) {
        Vector3D[] tangent = tangentVector(uParam, vParam);

        return new SurfaceCurvature3D(-1.0 / radius, tangent[0].unitized(),
                0, tangent[1].unitized());
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì•Î“ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½Ô‚ï¿½?B
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½Î“ï¿½ï¿½ï¿½?ï¿½
     */
    public SurfaceDerivative3D evaluation(double uParam, double vParam) {
        CartesianTransformationOperator3D gtrans = toGlobal();
        double x = radius * Math.cos(uParam);
        double y = radius * Math.sin(uParam);
        // p    = (x, y, vParam)
        // dup  = (-y, x, 0)
        // dvp  = (0, 0, 1)
        // duup = (-x, -y, 0);
        // duvp = (0, 0, 0)
        // dvvp = (0, 0, 0)

        Point3D pnt = new CartesianPoint3D(x, y, vParam);
        Vector3D dup = new LiteralVector3D(-y, x, 0.0);
        Vector3D dvp = Vector3D.zUnitVector;
        Vector3D duup = new LiteralVector3D(-x, -y, 0.0);
        Vector3D zerov = Vector3D.zeroVector;

        return new SurfaceDerivative3D(gtrans.transform(pnt),
                gtrans.transform(dup),
                gtrans.transform(dvp),
                gtrans.transform(duup),
                gtrans.transform(zerov),
                gtrans.transform(zerov));
    }

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ç‚±ï¿½Ì‹È–Ê‚Ö‚Ì“ï¿½ï¿½eï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚Ì’ï¿½?Sï¿½ï¿½?ï¿½É‚È‚ï¿½ï¿½ï¿½?A
     * ?ï¿½É“ï¿½Â‚Ì“ï¿½ï¿½eï¿½_ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½Æ‚ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚Ì’ï¿½?Sï¿½ï¿½ï¿½Æ‚Ì‹ï¿½ï¿½ï¿½ï¿½ï¿½?A
     * ï¿½ï¿½?ï¿½?Ý’è‚³ï¿½ï¿½Ä‚ï¿½ï¿½é‰‰ï¿½Z?ï¿½?ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½
     * ?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * IndefiniteSolutionException ï¿½Ì—ï¿½Oï¿½ð“Š‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param point ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_
     * @return ï¿½ï¿½ï¿½eï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½ (ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_ï¿½ï¿½ï¿½~ï¿½ï¿½ï¿½Ê‚Ì’ï¿½?Sï¿½ï¿½?ï¿½É‚ï¿½ï¿½ï¿½)
     */
    public PointOnSurface3D[] projectFrom(Point3D point)
            throws IndefiniteSolutionException {
        CartesianTransformationOperator3D gtrans = toGlobal();
        Point3D lpoint = gtrans.reverseTransform(point);
        double z = lpoint.z();
        Point3D apoint = new CartesianPoint3D(0.0, 0.0, z);
        Vector3D eduvec = lpoint.subtract(apoint);

        ConditionOfOperation condition =
                ConditionOfOperation.getCondition();
        double dTol = Math.abs(condition.getToleranceForDistance());

        if (eduvec.length() < dTol) {
            PointOnSurface3D p;

            try {
                p = new PointOnSurface3D(this, 0.0, z, doCheckDebug);
            } catch (InvalidArgumentValueException e) {
                throw new FatalException();
            }

            throw new IndefiniteSolutionException(p);
        }
        eduvec = eduvec.unitized();

        // get vector angle
        double u = Math.atan2(eduvec.y(), eduvec.x());

        if (u < 0)
            u += 2 * Math.PI;
        PointOnSurface3D foot1 = new PointOnSurface3D(this, u, z, doCheckDebug);
        u += Math.PI;
        if (u >= 2 * Math.PI)
            u -= 2 * Math.PI;
        PointOnSurface3D foot2 = new PointOnSurface3D(this, u, z, doCheckDebug);

        PointOnSurface3D[] proj = {foot1, foot2};

        return proj;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D ï¿½ï¿½
     * ï¿½ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tol   ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ð•½–Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Q
     * @see PointOnSurface3D
     */
    public Mesh3D
    toMesh(ParameterSection uPint,
           ParameterSection vPint,
           ToleranceForDistance tol) {
        return this.makeMesh(1, uPint, vPint, tol);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D ï¿½ï¿½
     * ï¿½ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param meshType toMesh ï¿½ï¿½ï¿½ï¿½È‚ï¿½ 1 ?AtoNonStructuredPoints ï¿½ï¿½ï¿½ï¿½È‚ï¿½ 2
     * @param uPint    U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint    V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tol      ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ð•½–Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Q
     * @see PointOnSurface3D
     * @see #toMesh(ParameterSection,ParameterSection,ToleranceForDistance)
     * @see #toNonStructuredPoints(ParameterSection,ParameterSection,double,double[])
     */
    private Mesh3D
    makeMesh(int meshType,
             ParameterSection uPint,
             ParameterSection vPint,
             ToleranceForDistance tol) {
        PointOnSurface3D[][] mesh;
        double uParam;
        double vStart = vPint.start();
        double vEnd = vPint.end();
        double vMiddle = (vStart + vEnd) / 2.0;
        Polyline3D pol;
        int u_npnts;
        PointOnCurve3D poc;
        Point3D pnt;
        Point3D pnt2;
        Vector3D vec;
        Vector3D vec2;
        int i;

        /*
        * Vï¿½ï¿½ï¿½ÌŠJï¿½nï¿½Ê’uï¿½Å‚Ì’fï¿½Ê‚Æ‚È‚ï¿½~ï¿½ï¿½?ï¿½ï¿½?A
        * ï¿½ï¿½ï¿½ï¿½É‰~ï¿½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ßŽï¿½ï¿½ï¿½ï¿½ï¿½?B
        * ï¿½ï¿½ï¿½ï¿½?ß“_ï¿½ï¿½Vï¿½ï¿½ï¿½Jï¿½nï¿½Ê’uï¿½Å‚ÌŠiï¿½qï¿½_ï¿½Æ‚È‚ï¿½?B
        */
        try {
            CartesianTransformationOperator3D gtrans = toGlobal();
            Point3D cntr;
            Axis2Placement3D pos;
            Circle3D cir;

            pnt = new CartesianPoint3D(0.0, 0.0, vStart);    // ï¿½ï¿½?Sï¿½ï¿½?ï¿½ß‚ï¿½?B
            cntr = gtrans.transform(pnt);

            pos = new Axis2Placement3D(cntr, position().z(), position().x());
            cir = new Circle3D(pos, radius());        // ï¿½~ï¿½ï¿½?ï¿½ß‚ï¿½?B

            pol = cir.toPolyline(uPint, tol);
        } catch (InvalidArgumentValueException e) {
            throw new FatalException();
        }

        /*
        * Vï¿½ï¿½ï¿½ÌŠJï¿½nï¿½_ï¿½ÌŠiï¿½qï¿½_ï¿½ï¿½Vï¿½ï¿½ï¿½ï¿½?Iï¿½ï¿½ï¿½_ï¿½ÖƒRï¿½s?[ï¿½ï¿½?A
        * ï¿½iï¿½qï¿½_ï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½?B
        */
        u_npnts = pol.nPoints();
        vec = position().z().multiply(vPint.increase());

        if (meshType == 1) {
            vec2 = null;
            mesh = new PointOnSurface3D[u_npnts][2];
        } else {
            vec2 = position().z().multiply(vPint.increase() / 2.0);
            mesh = new PointOnSurface3D[u_npnts][3];
        }

        for (i = 0; i < u_npnts; i++) {
            try {
                poc = (PointOnCurve3D) pol.pointAt(i);
                pnt = new CartesianPoint3D(poc.x(), poc.y(), poc.z());
                uParam = poc.parameter();
                mesh[i][0] = new PointOnSurface3D(pnt, this, uParam, vStart, doCheckDebug);
                if (meshType == 1) {
                    pnt = pnt.add(vec);
                    mesh[i][1] = new PointOnSurface3D(pnt, this, uParam, vEnd, doCheckDebug);
                } else {
                    pnt2 = pnt.add(vec2);
                    mesh[i][1] = new PointOnSurface3D(pnt, this, uParam, vMiddle, doCheckDebug);
                    pnt = pnt.add(vec);
                    mesh[i][2] = new PointOnSurface3D(pnt, this, uParam, vEnd, doCheckDebug);
                }
            } catch (InvalidArgumentValueException e) {
                throw new FatalException();
            }
        }

        return new Mesh3D(mesh, false);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ìµ–ï¿½ï¿½ï¿½?ÄŒï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½? Bspline ï¿½È–Ê‚ï¿½Ô‚ï¿½?B
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ï¿½?ÄŒï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½? Bspline ï¿½È–ï¿½
     */
    public BsplineSurface3D
    toBsplineSurface(ParameterSection uPint,
                     ParameterSection vPint) {
        Circle2D circle2D =
                new Circle2D(Axis2Placement2D.origin, this.radius());

        BsplineCurve2D uBsplineCurve2D = circle2D.toBsplineCurve(uPint);

        int uNPoints = uBsplineCurve2D.nControlPoints();
        int vNPoints = 2;

        Point3D[][] controlPoints = new Point3D[uNPoints][vNPoints];
        double[][] weights = new double[uNPoints][vNPoints];

        CartesianTransformationOperator3D localTransformationOperator =
                this.position().toCartesianTransformationOperator(1.0);

        double vLowerCoord = vPint.start();
        double vUpperCoord = vPint.end();

        for (int ui = 0; ui < uNPoints; ui++) {
            Point2D uPoint = uBsplineCurve2D.controlPointAt(ui);
            controlPoints[ui][0] =
                    localTransformationOperator.toEnclosed(uPoint.to3D(vLowerCoord));
            controlPoints[ui][1] =
                    localTransformationOperator.toEnclosed(uPoint.to3D(vUpperCoord));
            weights[ui][0] = weights[ui][1] = uBsplineCurve2D.weightAt(ui);
        }

        return new BsplineSurface3D(uBsplineCurve2D.knotData(),
                BsplineKnot.quasiUniformKnotsOfLinearOneSegment,
                controlPoints, weights);
    }

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹È–ï¿½?ï¿½É‚ï¿½ï¿½é‚©ï¿½Û‚ï¿½ï¿½ï¿½`ï¿½Fï¿½bï¿½Nï¿½ï¿½ï¿½ï¿½?B
     *
     * @param point ?ï¿½ï¿½?ï¿½ï¿½?Û‚Æ‚È‚ï¿½_
     * @return ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹È–ï¿½?ï¿½É‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     */
    boolean checkSolution(Point3D point) {
        double dTol = getToleranceForDistance();
        double dist = Math.sqrt(point.x() * point.x() + point.y() * point.y());
        return Math.abs(dist - radius()) < dTol;
    }

    /**
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½È–Ê‚ï¿½ (ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ê‚½) ï¿½ï¿½ï¿½Rï¿½ï¿½?ï¿½ÌŒï¿½_ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     *
     * @param poly ï¿½xï¿½Wï¿½Gï¿½ï¿½?ï¿½é‚¢ï¿½Í‚aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½?ï¿½Ì‚ï¿½ï¿½ï¿½Zï¿½Oï¿½?ï¿½ï¿½ï¿½gï¿½Ì‘ï¿½?ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½Ì”zï¿½ï¿½
     * @return ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½È–Ê‚ï¿½ poly ï¿½ÌŒï¿½_ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½
     */
    DoublePolynomial makePoly(DoublePolynomial[] poly) {
        DoublePolynomial xPoly = (DoublePolynomial) poly[0].multiply(poly[0]);
        DoublePolynomial yPoly = (DoublePolynomial) poly[1].multiply(poly[1]);
        double radius2 = this.radius() * this.radius();
        boolean isPoly = poly.length < 4;
        int degree = xPoly.degree();
        double[] coef = new double[degree + 1];
        if (isPoly) {
            for (int j = 0; j <= degree; j++) {
                coef[j] = xPoly.getCoefficientAsDouble(j) +
                        yPoly.getCoefficientAsDouble(j);
            }
            coef[0] -= radius2;
        } else {
            DoublePolynomial wPoly = (DoublePolynomial) poly[3].multiply(poly[3]);
            for (int j = 0; j <= degree; j++) {
                coef[j] = xPoly.getCoefficientAsDouble(j) +
                        yPoly.getCoefficientAsDouble(j) -
                        (radius2 * wPoly.getCoefficientAsDouble(j));
            }
        }
        return new DoublePolynomial(coef);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    public IntersectionPoint3D[] intersect(ParametricCurve3D mate)
            throws IndefiniteSolutionException {
        return mate.intersect(this, true);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½)
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    IntersectionPoint3D[] intersect(Line3D mate, boolean doExchange)
            throws IndefiniteSolutionException {
        // tolerance
        double aTol = getToleranceForAngle();
        double dTol = getToleranceForDistance();

        Vector3D unit_dir = mate.dir().unitized(); // line's unit dir
        Vector3D cyl_axis = position().z();        // cylinder's axis
        Point3D cyl_org = position().location();   // cylinder's origin

        if (Math.abs(unit_dir.dotProduct(cyl_axis)) > Math.cos(aTol)) {
            // Line & Cylinder are parallel
            Vector3D pnt_to_org = cyl_org.subtract(mate.pnt());
            double innerProduct = pnt_to_org.dotProduct(unit_dir);
            double[] pnt = new double[3];
            pnt[0] = mate.pnt().x() + innerProduct * unit_dir.x();
            pnt[1] = mate.pnt().y() + innerProduct * unit_dir.y();
            pnt[2] = mate.pnt().z() + innerProduct * unit_dir.z();
            CartesianPoint3D projected_org = new CartesianPoint3D(pnt[0], pnt[1], pnt[2]);
            Vector3D org_to_line = projected_org.subtract(cyl_org);
            if (Math.abs(org_to_line.length() - radius()) < dTol) {
                // overlap
                throw new IndefiniteSolutionException(mate.pnt());
            }
            return new IntersectionPoint3D[0];
        }

        // transform line to cylinder's local coordinates
        CartesianTransformationOperator3D trans = new
                CartesianTransformationOperator3D(position(), 1.0);

        Point3D ppnt = trans.reverseTransform(mate.pnt());
        Vector3D pvector = trans.reverseTransform(mate.dir());
        Line3D translated_line = new Line3D(ppnt, pvector);

        // resolve in 2D
        CartesianPoint2D cir_org = new CartesianPoint2D(0.0, 0.0);
        Circle2D circle = new Circle2D(cir_org, radius());
        Line2D line2 = mate.toLocal2D(trans);

        IntersectionPoint2D[] int_pnt2d = new IntersectionPoint2D[0];

        try {
            int_pnt2d = circle.intersect(line2);
        } catch (IndefiniteSolutionException e) {
            // IndefiniteSolutionException doesnt happen !
        }

        if (int_pnt2d.length == 0)
            return new IntersectionPoint3D[0];

        IntersectionPoint3D[] int_pnt = new IntersectionPoint3D[int_pnt2d.length];
        double cyl_param;
        double line_param;

        for (int i = 0; i < int_pnt2d.length; i++) {
            line_param = int_pnt2d[i].pointOnCurve2().parameter();
            cyl_param = int_pnt2d[i].pointOnCurve1().parameter();
            Point3D pnt = mate.coordinates(line_param);

            double height_param =
                    translated_line.pnt().z() + line_param * translated_line.dir().z();

            // point on line
            PointOnCurve3D PonC = new PointOnCurve3D(pnt, mate, line_param, doCheckDebug);

            // point on surface
            PointOnSurface3D PonS =
                    new PointOnSurface3D(pnt, this, cyl_param, height_param, doCheckDebug);

            // intersection point
            if (doExchange)
                int_pnt[i] = new IntersectionPoint3D(pnt, PonC, PonS, doCheckDebug);
            else
                int_pnt[i] = new IntersectionPoint3D(pnt, PonS, PonC, doCheckDebug);
        }
        return int_pnt;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–Ê‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate ï¿½ï¿½ï¿½Ì‹È–ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException mate ï¿½ï¿½~ï¿½ï¿½ï¿½Ê‚ï¿½?Aï¿½ï¿½ï¿½Ò‚ï¿½ï¿½I?[ï¿½o?[ï¿½ï¿½ï¿½bï¿½vï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?Aï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    public SurfaceSurfaceInterference3D[] intersect(ParametricSurface3D mate)
            throws IndefiniteSolutionException {
        return mate.intersect(this, true);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½) ï¿½ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * [ï¿½Õ”?ï¿½ï¿½?]
     * <br>
     * ï¿½ï¿½ï¿½Ê‚ÌƒNï¿½ï¿½ï¿½Xï¿½ï¿½?uï¿½ï¿½ï¿½ï¿½ vs. ï¿½~ï¿½ï¿½ï¿½ï¿½?vï¿½ÌŒï¿½?ï¿½?ï¿½\ï¿½bï¿½h
     * {@link Plane3D#intersect(CylindricalSurface3D,boolean)
     * Plane3D.intersect(CylindricalSurface3D, boolean)}
     * ï¿½ï¿½Ä‚ï¿½?oï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½Ì”zï¿½ï¿½
     */
    SurfaceSurfaceInterference3D[] intersect(Plane3D mate, boolean doExchange) {
        return mate.intersect(this, !doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½) ï¿½ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * [ï¿½Õ”?ï¿½ï¿½?]
     * <br>
     * ï¿½ï¿½?Û‚Ì‰ï¿½ï¿½Zï¿½ï¿½
     * {@link IntsSphCyl3D#intersection(SphericalSurface3D,CylindricalSurface3D,boolean)
     * IntsSphCyl3D.intersection}(mate, this, !doExchange)
     * ï¿½ï¿½?sï¿½È‚BÄ‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½Ì”zï¿½ï¿½
     */
    SurfaceSurfaceInterference3D[] intersect(SphericalSurface3D mate,
                                             boolean doExchange) {
        return IntsSphCyl3D.intersection(mate, this, !doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~ï¿½ï¿½ï¿½ï¿½) ï¿½ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * [ï¿½Õ”?ï¿½ï¿½?]
     * <br>
     * ï¿½ï¿½?Û‚Ì‰ï¿½ï¿½Zï¿½ï¿½
     * {@link IntsCylCyl3D#intersection(CylindricalSurface3D,CylindricalSurface3D,boolean)
     * IntsCylCyl3D.intersection}(this, mate, doExchange)
     * ï¿½ï¿½?sï¿½È‚BÄ‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~ï¿½ï¿½ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½ï¿½ï¿½Ò‚ï¿½ï¿½I?[ï¿½o?[ï¿½ï¿½ï¿½bï¿½vï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?Aï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    SurfaceSurfaceInterference3D[] intersect(CylindricalSurface3D mate,
                                             boolean doExchange)
            throws IndefiniteSolutionException {
        return IntsCylCyl3D.intersection(this, mate, doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~??ï¿½ï¿½) ï¿½ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * [ï¿½Õ”?ï¿½ï¿½?]
     * <br>
     * ï¿½ï¿½?Û‚Ì‰ï¿½ï¿½Zï¿½ï¿½
     * {@link IntsCylCon3D#intersection(CylindricalSurface3D,ConicalSurface3D,boolean)
     * IntsCylCon3D.intersection}(this, mate, doExchange)
     * ï¿½ï¿½?sï¿½È‚BÄ‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~??ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½Ì”zï¿½ï¿½
     */
    SurfaceSurfaceInterference3D[] intersect(ConicalSurface3D mate,
                                             boolean doExchange) {
        return IntsCylCon3D.intersection(this, mate, doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½xï¿½Wï¿½Gï¿½È–ï¿½) ï¿½ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * [ï¿½Õ”?ï¿½ï¿½?]
     * <br>
     * ï¿½ï¿½?Û‚Ì‰ï¿½ï¿½Zï¿½ï¿½
     * {@link IntsQrdBzs3D#intersection(ElementarySurface3D,PureBezierSurface3D,boolean)
     * IntsQrdBzs3D.intersection}(this, mate, doExchange)
     * ï¿½ï¿½?sï¿½È‚BÄ‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½xï¿½Wï¿½Gï¿½È–ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½Ì”zï¿½ï¿½
     */
    SurfaceSurfaceInterference3D[] intersect(PureBezierSurface3D mate,
                                             boolean doExchange) {
        return IntsQrdBzs3D.intersection(this, mate, doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½È–ï¿½) ï¿½ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * [ï¿½Õ”?ï¿½ï¿½?]
     * <br>
     * ï¿½ï¿½?Û‚Ì‰ï¿½ï¿½Zï¿½ï¿½
     * {@link IntsSrfBss3D#intersection(ElementarySurface3D,BsplineSurface3D,boolean)
     * IntsSrfBss3D.intersection}(this, mate, doExchange)
     * ï¿½ï¿½?sï¿½È‚BÄ‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½È–ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½Ì”zï¿½ï¿½
     */
    SurfaceSurfaceInterference3D[] intersect(BsplineSurface3D mate,
                                             boolean doExchange) {
        return IntsSrfBss3D.intersection(this, mate, doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½ï¿½ï¿½ï¿½È–Ê‚ï¿½
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½ Bspline ï¿½È–Ê‚ï¿½?ï¿½ß‚ï¿½?B
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param magni ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½
     * @param side  ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ÌŒï¿½ (WhichSide.FRONT/BACK)
     * @param tol   ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½`ï¿½ï¿½Ô‚ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½È–Ê‚ï¿½ßŽï¿½ï¿½ï¿½ï¿½ï¿½ Bspline ï¿½È–ï¿½
     * @see WhichSide
     */
    public BsplineSurface3D
    offsetByBsplineSurface(ParameterSection uPint,
                           ParameterSection vPint,
                           double magni,
                           int side,
                           ToleranceForDistance tol) {
        Ofst3D doObj = new Ofst3D(this, uPint, vPint, magni, side, tol);
        return doObj.offset();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½é“™ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½ï¿½Ô‚ï¿½?B
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½wï¿½ï¿½ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì“ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½
     */
    public ParametricCurve3D uIsoParametricCurve(double uParam) {
        Point3D pnt = coordinates(uParam, 0.0);
        Vector3D dir = position().z();
        return new Line3D(pnt, dir);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½é“™ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½ï¿½Ô‚ï¿½?B
     *
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½wï¿½ï¿½ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì“ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½
     */
    public ParametricCurve3D vIsoParametricCurve(double vParam) {
        Point3D pnt = position().location().add(position().z().multiply(vParam));
        Axis2Placement3D a2p = new Axis2Placement3D(pnt, position().z(), position().x());
        return new Circle3D(a2p, radius());
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½Lï¿½ÅŽï¿½ï¿½Iï¿½È’ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½
     */
    ParameterDomain getUParameterDomain() {
        try {
            return new ParameterDomain(true, 0, 2 * Math.PI);
        } catch (InvalidArgumentValueException e) {
            // should never be occurred
            throw new FatalException();
        }
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Å”ï¿½ï¿½ï¿½Iï¿½È’ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½
     */
    ParameterDomain getVParameterDomain() {
        return new ParameterDomain();
    }

    /**
     * ï¿½vï¿½fï¿½ï¿½Ê‚ï¿½Ô‚ï¿½?B
     *
     * @return {@link ParametricSurface3D#CYLINDRICAL_SURFACE_3D ParametricSurface3D.CYLINDRICAL_SURFACE_3D}
     */
    int type() {
        return CYLINDRICAL_SURFACE_3D;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½ï¿½ (ï¿½Ì’ï¿½?Sï¿½ï¿½) ï¿½ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½~ï¿½ï¿½ï¿½ï¿½ (ï¿½Ì’ï¿½?Sï¿½ï¿½) ï¿½ï¿½ï¿½ï¿½?sï¿½ï¿½ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½ð”»’è‚·ï¿½ï¿½?B
     * <p/>
     * ï¿½ï¿½Â‚Ì‰~ï¿½ï¿½ï¿½Ê‚Ì‹ï¿½?ï¿½ Z ï¿½ï¿½ï¿½Ì‚È‚ï¿½ï¿½pï¿½xï¿½ï¿½ ï¿½ï¿½ï¿½é‚¢ï¿½ï¿½ (ï¿½ï¿½ - ï¿½ï¿½) ï¿½ï¿½
     * ï¿½ï¿½?ï¿½?Ý’è‚³ï¿½ï¿½Ä‚ï¿½ï¿½é‰‰ï¿½Z?ï¿½?ï¿½ÌŠpï¿½xï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½ï¿½?sï¿½Å‚ï¿½ï¿½ï¿½ï¿½Ì‚Æ‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate ï¿½ï¿½ï¿½ï¿½ï¿½?Û‚Ì‰~ï¿½ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?sï¿½Å‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     */
    boolean isParallel(CylindricalSurface3D mate) {
        Vector3D thisAxis = this.position().z();
        Vector3D mateAxis = mate.position().z();
        double dot = thisAxis.dotProduct(mateAxis);

        return Math.abs(dot) > Math.cos(getToleranceForAngle());
    }

    /**
     * ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½~ï¿½ï¿½ï¿½Ê‚ï¿½ï¿½ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚Æ‚Ý‚È‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½ï¿½ð”»’è‚·ï¿½ï¿½?B
     *
     * @param mate ï¿½ï¿½ï¿½ï¿½ï¿½?Û‚Ì‰~ï¿½ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚Æ‚Ý‚È‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     */
    boolean equals(CylindricalSurface3D mate) {
        if (isParallel(mate)) {
            Point3D source = mate.position().location();
            PointOnCurve3D[] foot = getAxis().projectFrom(source);

            if (foot.length != 1) throw new FatalException();

            double dist = source.distance(foot[0]);
            double dTol = getToleranceForDistance();

            if (dist < dTol)
                if (Math.abs(radius() - mate.radius()) < dTol)
                    return true;
        }
        return false;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‰~ï¿½ï¿½ï¿½Ê‚Ì’ï¿½?Sï¿½ï¿½ï¿½Æ‚È‚é’¼?ï¿½ï¿½Ô‚ï¿½?B
     *
     * @return ï¿½ï¿½?Sï¿½ï¿½ï¿½î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    Line3D getAxis() {
        return new Line3D(position().location(), position().z());
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ?ï¿½ï¿½?ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä“ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Qï¿½Íˆï¿½Ê‚ï¿½?Aï¿½Ê‘ï¿½ï¿½Iï¿½É‚ï¿½ô‰½“Iï¿½É‚ï¿½?Aï¿½iï¿½q?ï¿½Å‚Í‚È‚ï¿½?B
     * </p>
     * <p/>
     * scalingFactor ï¿½ï¿½?Aï¿½ï¿½Í—pï¿½Å‚Í‚È‚ï¿½?A?oï¿½Í—pï¿½Ìˆï¿½?ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * scalingFactor ï¿½É‚ï¿½?Aï¿½vï¿½f?ï¿½ 2 ï¿½Ì”zï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½?B
     * scalingFactor[0] ï¿½É‚ï¿½ U ï¿½ï¿½ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½?A
     * scalingFactor[1] ï¿½É‚ï¿½ V ï¿½ï¿½ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½ï¿½Ì’lï¿½Í‰ï¿½ï¿½ç‚©ï¿½ï¿½?ï¿½Î’lï¿½Å‚Í‚È‚ï¿½?A
     * ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?iï¿½Þ‘ï¿½ï¿½x T ï¿½É‘Î‚ï¿½ï¿½ï¿½?A
     * U/V ï¿½ï¿½ï¿½ï¿½ï¿½É‚Â‚ï¿½ï¿½ÄŽï¿½ï¿½?ï¿½Å‹È–ï¿½?ï¿½Ì“_ï¿½ï¿½?iï¿½Þ‘ï¿½ï¿½x Pu/Pv ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½Î’lï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½Â‚Ü‚ï¿½?Aï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ T ï¿½ï¿½ï¿½ï¿½?iï¿½Þ‚ï¿½?A
     * ï¿½ï¿½ï¿½?ï¿½Å‚Ì‹È–ï¿½?ï¿½Ì“_ï¿½ï¿½ U ï¿½ï¿½ï¿½Å‚ï¿½ Pu (scalingFactor[0])?A
     * V ï¿½ï¿½ï¿½Å‚ï¿½ Pv (scalingFactor[1]) ï¿½ï¿½ï¿½ï¿½?iï¿½Þ‚ï¿½ï¿½Æ‚ï¿½\ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?B
     * T ï¿½Ì‘å‚«ï¿½ï¿½ï¿½Í–ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½Ì‚ï¿½?Aï¿½ï¿½ï¿½Ì’lï¿½ï¿½Q?Æ‚ï¿½ï¿½ï¿½?Û‚É‚ï¿½?A
     * scalingFactor[0] ï¿½ï¿½ scalingFactor[1] ï¿½Ì”ä‚¾ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½ï¿½×‚ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½È‚ï¿½?Aï¿½ï¿½ï¿½ï¿½ï¿½Ì’lï¿½Í‚ï¿½ï¿½ï¿½ï¿½Ü‚Å‚ï¿½ÚˆÅ‚ï¿½ï¿½ï¿½?Aï¿½ï¿½ï¿½ï¿½ï¿½È‘ï¿½ï¿½xï¿½î¦‚ï¿½ï¿½ï¿½Ì‚Å‚Í‚È‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ Vector ï¿½ÉŠÜ‚Ü‚ï¿½ï¿½eï¿½vï¿½fï¿½ï¿½
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D
     * ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParameterSection U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vParameterSection V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tolerance         ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @param scalingFactor     ï¿½_ï¿½Qï¿½ï¿½Oï¿½pï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?Û‚É—Lï¿½pï¿½ÆŽvï¿½ï¿½ï¿½ï¿½ U/V ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½
     * @return ï¿½_ï¿½Qï¿½ï¿½Ü‚ï¿½ Vector
     * @see PointOnSurface3D
     */
    public Vector toNonStructuredPoints(ParameterSection uParameterSection,
                                        ParameterSection vParameterSection,
                                        double tolerance,
                                        double[] scalingFactor) {
        Vector result = new Vector();

        Mesh3D mesh = this.makeMesh(2, uParameterSection, vParameterSection,
                new ToleranceForDistance(tolerance));

        for (int u = 0; u < mesh.uNPoints(); u++)
            for (int v = 0; v < mesh.vNPoints(); v++)
                result.addElement(mesh.pointAt(u, v));

        scalingFactor[0] = this.radius();
        scalingFactor[1] = 1.0;

        return result;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * transformedGeometries ï¿½ï¿½?A
     * ï¿½ÏŠï¿½ï¿½Oï¿½ÌŠô‰½—vï¿½fï¿½ï¿½L?[ï¿½Æ‚ï¿½?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½fï¿½ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½nï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?Û‚Éƒ?ï¿½\ï¿½bï¿½hï¿½Õ”ï¿½Å‚ï¿½ this ï¿½ï¿½L?[?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ê‚ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½ transformedGeometries ï¿½É’Ç‰Bï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉŠï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ï¿½ï¿½?Û‚Ì•ÏŠï¿½ï¿½ï¿½?sï¿½È‚í‚¸?Aï¿½ï¿½ï¿½ÌƒL?[ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½?Ä‹Aï¿½Iï¿½ï¿½?sï¿½È‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * transformedGeometries ï¿½ï¿½ null ï¿½Å‚ï¿½?\ï¿½ï¿½È‚ï¿½?B
     * transformedGeometries ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ?ï¿½ï¿½ this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param reverseTransform       ï¿½tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½Ì‚Å‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     * @param transformationOperator ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½q
     * @param transformedGeometries  ï¿½ï¿½É“ï¿½ï¿½lï¿½Ì•ÏŠï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ô‰½—vï¿½fï¿½ï¿½Ü‚Þƒnï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½
     * @return ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½f
     */
    protected synchronized ParametricSurface3D
    doTransformBy(boolean reverseTransform,
                  CartesianTransformationOperator3D transformationOperator,
                  java.util.Hashtable transformedGeometries) {
        Axis2Placement3D tPosition =
                this.position().transformBy(reverseTransform,
                        transformationOperator,
                        transformedGeometries);
        double tRadius;
        if (reverseTransform != true)
            tRadius = transformationOperator.transform(this.radius());
        else
            tRadius = transformationOperator.reverseTransform(this.radius());
        return new CylindricalSurface3D(tPosition, tRadius);
    }

    /**
     * ?oï¿½ÍƒXï¿½gï¿½ï¿½?[ï¿½ï¿½ï¿½ÉŒ`?ï¿½?ï¿½ï¿½ï¿½?oï¿½Í‚ï¿½ï¿½ï¿½?B
     *
     * @param writer PrintWriter
     * @param indent ï¿½Cï¿½ï¿½ï¿½fï¿½ï¿½ï¿½gï¿½ï¿½?[ï¿½ï¿½
     * @see GeometryElement
     */
    protected void output(PrintWriter writer, int indent) {
        String indent_tab = makeIndent(indent);

        writer.println(indent_tab + getClassName());
        writer.println(indent_tab + "\tposition");
        position().output(writer, indent + 2);
        writer.println(indent_tab + "\tradius\t" + radius);
        writer.println(indent_tab + "End");
    }
}
