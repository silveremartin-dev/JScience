/*
 * ï¿½Rï¿½ï¿½ï¿½ï¿½ : ï¿½ï¿½ï¿½Ê‚ï¿½\ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½X
 *
 * Copyright 2000 by Information-technology Promotion Agency, Japan
 * Copyright 2000 by Precision Modeling Laboratory, Inc., Tokyo, Japan
 * Copyright 2000 by Software Research Associates, Inc., Tokyo, Japan
 *
 * $Id: SurfaceOfLinearExtrusion3D.java,v 1.3 2006/03/01 21:16:11 virtualcall Exp $
 */

package org.jscience.mathematics.geometry;

import org.jscience.util.FatalException;

import java.io.PrintWriter;
import java.util.Vector;

/**
 * ï¿½Rï¿½ï¿½ï¿½ï¿½ : ï¿½ï¿½ï¿½Ê‚ï¿½\ï¿½ï¿½ï¿½Nï¿½ï¿½ï¿½X?B
 * <p/>
 * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½?A
 * ï¿½ï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½â ‚ï¿½ï¿½ï¿½É‚Ü‚Bï¿½ï¿½ï¿½ï¿½|ï¿½ï¿½ (ï¿½Xï¿½C?[ï¿½v) ï¿½ï¿½ï¿½ï¿½ï¿½O?Õ‚ï¿½È–Ê‚Æ‚Ý‚È‚ï¿½ï¿½ï¿½Ì‚Å‚ï¿½ï¿½ï¿½?B
 * </p>
 * <p/>
 * ï¿½ï¿½ï¿½ÌƒNï¿½ï¿½ï¿½Xï¿½ÌƒCï¿½ï¿½ï¿½Xï¿½^ï¿½ï¿½ï¿½Xï¿½ï¿½?A
 * ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½×‚ï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ sweptCurve
 * ï¿½ï¿½
 * sweptCurve ï¿½ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½î¦‚ï¿½ï¿½xï¿½Nï¿½gï¿½ï¿½ extrusionAxis
 * ï¿½ï¿½ÛŽ?ï¿½ï¿½ï¿½ï¿½?B
 * ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?AsweptCurve ï¿½ï¿½ {@link SweptSurface3D ï¿½X?[ï¿½p?[ï¿½Nï¿½ï¿½ï¿½X} ï¿½ï¿½Å•ÛŽ?ï¿½ï¿½ï¿½ï¿½ï¿½?B
 * </p>
 * <p/>
 * ï¿½ï¿½ï¿½Ê‚ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½ï¿½?AsweptCurve ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½Éˆï¿½vï¿½ï¿½ï¿½ï¿½?B
 * V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½Í–ï¿½ï¿½Å”ï¿½ï¿½ï¿½Iï¿½Å‚ï¿½ï¿½ï¿½?B
 * </p>
 * <p/>
 * (u, v) ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Æ‚ï¿½ï¿½é’Œï¿½ï¿½ P(u, v) ï¿½Ìƒpï¿½ï¿½ï¿½?ï¿½gï¿½ï¿½ï¿½bï¿½Nï¿½\ï¿½ï¿½ï¿½ï¿½?Aï¿½È‰ï¿½ï¿½Ì’Ê‚ï¿½?B
 * <pre>
 * 	P(u, v) = sweptCurve(u) + v * extrusionAxis
 * </pre>
 *
 * @author Information-technology Promotion Agency, Japan
 * @version $Revision: 1.3 $, $Date: 2006/03/01 21:16:11 $
 */

public class SurfaceOfLinearExtrusion3D extends SweptSurface3D {
    /**
     * ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?B
     *
     * @serial
     */
    private Vector3D extrusionAxis;

    /**
     * ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ÆƒXï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ÄƒIï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½?\ï¿½zï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * sweptCurve ï¿½ï¿½ï¿½é‚¢ï¿½ï¿½ extrusionAxis ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½
     * InvalidArgumentValueException ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param sweptCurve    ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½
     * @param extrusionAxis ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     * @see InvalidArgumentValueException
     */
    public SurfaceOfLinearExtrusion3D(ParametricCurve3D sweptCurve,
                                      Vector3D extrusionAxis) {
        super(sweptCurve);
        setExtrusionAxis(extrusionAxis);
    }

    /**
     * ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½tï¿½B?[ï¿½ï¿½ï¿½hï¿½ï¿½?Ý’è‚·ï¿½ï¿½?B
     * <p/>
     * extrusionAxis ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½
     * InvalidArgumentValueException ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param extrusionAxis ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     * @see InvalidArgumentValueException
     */
    private void setExtrusionAxis(Vector3D extrusionAxis) {
        if (extrusionAxis == null) {
            throw new InvalidArgumentValueException();
        }
        this.extrusionAxis = extrusionAxis;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     *
     * @return ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     */
    public Vector3D extrusionAxis() {
        return extrusionAxis;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ï¿½?Wï¿½lï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ParameterOutOfRange ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?Wï¿½l
     * @see ParameterOutOfRange
     */
    public Point3D coordinates(double uParam, double vParam) {
        return sweptCurve().coordinates(uParam).add(extrusionAxis.multiply(vParam));
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½ï¿½ï¿½Å‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Æ‚ï¿½?Aï¿½pï¿½ï¿½ï¿½??[ï¿½^ U/V ï¿½ÌŠe?Xï¿½É‚Â‚ï¿½ï¿½Ä‚ÌˆêŽŸï¿½Î“ï¿½ï¿½ï¿½?ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½zï¿½ï¿½Ì—vï¿½f?ï¿½ï¿½ï¿½ 2 ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½zï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½Ì—vï¿½fï¿½É‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½?A
     * ï¿½ï¿½Ô–Ú‚Ì—vï¿½fï¿½É‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ü‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ParameterOutOfRange ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?Úƒxï¿½Nï¿½gï¿½ï¿½
     * @see ParameterOutOfRange
     */
    public Vector3D[] tangentVector(double uParam, double vParam) {
        Vector3D[] tng = new Vector3D[2];

        tng[0] = sweptCurve().tangentVector(uParam);
        tng[1] = extrusionAxis;
        return tng;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì•Î“ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ParameterOutOfRange ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½Î“ï¿½ï¿½ï¿½?ï¿½
     * @see ParameterOutOfRange
     */
    public SurfaceDerivative3D evaluation(double uParam, double vParam) {
        CurveDerivative3D crv_drv;
        Point3D d0;
        Vector3D du, dv, duu, duv, dvv;

        crv_drv = sweptCurve().evaluation(uParam);
        d0 = crv_drv.d0D().add(extrusionAxis.multiply(vParam));
        ;
        du = crv_drv.d1D();
        dv = extrusionAxis;
        duu = crv_drv.d2D();
        dvv = duv = Vector3D.zeroVector;
        return new SurfaceDerivative3D(d0, du, dv, duu, duv, dvv);
    }

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ç‚±ï¿½Ì‹È–Ê‚Ö‚Ì“ï¿½ï¿½eï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½eï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param point ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_
     * @return ï¿½ï¿½ï¿½eï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    public PointOnSurface3D[] projectFrom(Point3D point)
            throws IndefiniteSolutionException {
        // make plane include the sweptCurve.
        Line3D line = new Line3D(Point3D.origin, extrusionAxis);
        Point3D point_on_curve = sweptCurve().getPointNotOnLine(line);
        Vector3D normal = extrusionAxis;
        Plane3D plane = new Plane3D(point_on_curve, normal);

        // make projection from point to above plane.
        PointOnSurface3D lpoint = plane.projectFrom(point)[0];

        // make a AbstractCartesianTransformationOperator of lpoint.
        Axis2Placement3D position = new
                Axis2Placement3D(lpoint, normal,
                normal.verticalVector().unitized());
        CartesianTransformationOperator3D cto = new
                CartesianTransformationOperator3D(position, 1.0);

        // make projection on above plane.
        PointOnCurve3D[] lproj = sweptCurve().projectFrom(lpoint);
        // make projection to SweptSurface.
        PointOnSurface3D[] proj = new PointOnSurface3D[lproj.length];
        Vector3D vector = point.subtract(lpoint);
        double flag = 1.0;
        if (!normal.identicalDirection(vector)) {
            flag = -1.0;
        }
        double vParam = flag * Math.sqrt(vector.norm() / normal.norm());
        for (int i = 0; i < lproj.length; i++) {
            double uParam = lproj[i].parameter();
            proj[i] = new PointOnSurface3D(this, uParam, vParam, doCheckDebug);
        }

        return proj;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D ï¿½ï¿½
     * ï¿½ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ParameterOutOfRange ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tol   ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ð•½–Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Q
     * @see PointOnSurface3D
     * @see ParameterOutOfRange
     */
    public Mesh3D
    toMesh(ParameterSection uPint,
           ParameterSection vPint,
           ToleranceForDistance tol) {
        return this.makeMesh(1, uPint, vPint, tol);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D ï¿½ï¿½
     * ï¿½ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ParameterOutOfRange ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param meshType toMesh ï¿½ï¿½ï¿½ï¿½È‚ï¿½ 1 ?AtoNonStructuredPoints ï¿½ï¿½ï¿½ï¿½È‚ï¿½ 2
     * @param uPint    U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint    V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tol      ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ð•½–Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Q
     * @see PointOnSurface3D
     * @see ParameterOutOfRange
     */
    private Mesh3D
    makeMesh(int meshType,
             ParameterSection uPint,
             ParameterSection vPint,
             ToleranceForDistance tol) {
        PointOnSurface3D[][] mesh;
        Polyline3D pol;
        int u_npnts;
        PointOnCurve3D poc;
        double uParam;
        double vStart = vPint.start();
        double vEnd = vPint.end();
        double vMiddle = (vStart + vEnd) / 2.0;
        int i;

        /*
        * ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½ï¿½eï¿½ï¿½?ï¿½ï¿½Åƒ|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ßŽï¿½ï¿½ï¿½ï¿½ï¿½?B
        */
        pol = sweptCurve().toPolyline(uPint, tol);
        u_npnts = pol.nPoints();

        if (meshType == 1) {
            mesh = new PointOnSurface3D[u_npnts][2];
        } else {
            mesh = new PointOnSurface3D[u_npnts][3];
        }

        /*
        * Uï¿½ï¿½ï¿½Íƒ|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ì‹ßŽï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^?AVï¿½ï¿½ï¿½Íƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½Ô‚Ì—ï¿½ï¿½[ï¿½ÅŠiï¿½qï¿½_ï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½?B
        */
        for (i = 0; i < u_npnts; i++) {
            poc = (PointOnCurve3D) pol.pointAt(i);
            uParam = poc.parameter();
            try {
                mesh[i][0] = new PointOnSurface3D(this, uParam, vStart, doCheckDebug);
                if (meshType == 1) {
                    mesh[i][1] = new PointOnSurface3D(this, uParam, vEnd, doCheckDebug);
                } else {
                    mesh[i][1] = new PointOnSurface3D(this, uParam, vMiddle, doCheckDebug);
                    mesh[i][2] = new PointOnSurface3D(this, uParam, vEnd, doCheckDebug);
                }
            } catch (InvalidArgumentValueException e) {
                throw new FatalException();
            }
        }

        return new Mesh3D(mesh, false);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ìµ–ï¿½ï¿½ï¿½?ÄŒï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½Lï¿½? Bspline ï¿½È–Ê‚ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½`ï¿½ï¿½ï¿½Oï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ParameterOutOfRange ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ï¿½?ÄŒï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½? Bspline ï¿½È–ï¿½
     * @see ParameterOutOfRange
     */
    public BsplineSurface3D
    toBsplineSurface(ParameterSection uPint,
                     ParameterSection vPint) {
        BsplineCurve3D uBsplineCurve = this.sweptCurve().toBsplineCurve(uPint);

        int uNPoints = uBsplineCurve.nControlPoints();
        int vNPoints = 2;

        Point3D[][] controlPoints = new Point3D[uNPoints][vNPoints];
        double[][] weights = new double[uNPoints][vNPoints];

        Vector3D vLowerVec = this.extrusionAxis().multiply(vPint.start());
        Vector3D vUpperVec = this.extrusionAxis().multiply(vPint.end());

        for (int ui = 0; ui < uNPoints; ui++) {
            Point3D uPoint = uBsplineCurve.controlPointAt(ui);
            controlPoints[ui][0] = uPoint.add(vLowerVec);
            controlPoints[ui][1] = uPoint.add(vUpperVec);
            weights[ui][0] = weights[ui][1] = uBsplineCurve.weightAt(ui);
        }

        return new BsplineSurface3D(uBsplineCurve.knotData(),
                BsplineKnot.quasiUniformKnotsOfLinearOneSegment,
                controlPoints, weights);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½ï¿½ï¿½ï¿½È–Ê‚ï¿½
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½ Bspline ï¿½È–Ê‚ï¿½?ï¿½ß‚ï¿½?B
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param magni ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½
     * @param side  ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ÌŒï¿½ (WhichSide.FRONT/BACK)
     * @param tol   ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½`ï¿½ï¿½Ô‚ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½È–Ê‚ï¿½ßŽï¿½ï¿½ï¿½ï¿½ï¿½ Bspline ï¿½È–ï¿½
     * @see WhichSide
     */
    public BsplineSurface3D
    offsetByBsplineSurface(ParameterSection uPint,
                           ParameterSection vPint,
                           double magni,
                           int side,
                           ToleranceForDistance tol) {
        Ofst3D doObj = new Ofst3D(this, uPint, vPint, magni, side, tol);
        return doObj.offset();
    }

    /*
    * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½é“™ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½ï¿½Ô‚ï¿½?B
    *
    * @param uParam	U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
    * @return	ï¿½wï¿½ï¿½ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì“ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½
    */
    public ParametricCurve3D uIsoParametricCurve(double uParam) {
        return new Line3D(sweptCurve().coordinates(uParam), extrusionAxis);
    }

    /*
    * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½é“™ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½ï¿½Ô‚ï¿½?B
    *
    * @param vParam	V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
    * @return	ï¿½wï¿½ï¿½ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì“ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½
    */
    public ParametricCurve3D vIsoParametricCurve(double vParam) {
        Vector3D moveVec = extrusionAxis.multiply(vParam);
        return sweptCurve().parallelTranslate(moveVec);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½Xï¿½C?[ï¿½vï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @return U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½
     */
    ParameterDomain getUParameterDomain() {
        return sweptCurve().parameterDomain();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Å”ï¿½ï¿½ï¿½Iï¿½È’ï¿½`ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @return V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½`ï¿½ï¿½
     */
    ParameterDomain getVParameterDomain() {
        return new ParameterDomain();
    }

    /**
     * ï¿½vï¿½fï¿½ï¿½Ê‚ï¿½Ô‚ï¿½?B
     *
     * @return {@link ParametricSurface3D#SURFACE_OF_LINEAR_EXTRUSION_3D ParametricSurface3D.SURFACE_OF_LINEAR_EXTRUSION_3D}
     */
    int type() {
        return SURFACE_OF_LINEAR_EXTRUSION_3D;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ?ï¿½ï¿½?ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä“ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Qï¿½Íˆï¿½Ê‚ï¿½?Aï¿½Ê‘ï¿½ï¿½Iï¿½É‚ï¿½ô‰½“Iï¿½É‚ï¿½?Aï¿½iï¿½q?ï¿½Å‚Í‚È‚ï¿½?B
     * </p>
     * <p/>
     * scalingFactor ï¿½ï¿½?Aï¿½ï¿½Í—pï¿½Å‚Í‚È‚ï¿½?A?oï¿½Í—pï¿½Ìˆï¿½?ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * scalingFactor ï¿½É‚ï¿½?Aï¿½vï¿½f?ï¿½ 2 ï¿½Ì”zï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½?B
     * scalingFactor[0] ï¿½É‚ï¿½ U ï¿½ï¿½ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½?A
     * scalingFactor[1] ï¿½É‚ï¿½ V ï¿½ï¿½ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½ï¿½Ì’lï¿½Í‰ï¿½ï¿½ç‚©ï¿½ï¿½?ï¿½Î’lï¿½Å‚Í‚È‚ï¿½?A
     * ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?iï¿½Þ‘ï¿½ï¿½x T ï¿½É‘Î‚ï¿½ï¿½ï¿½?A
     * U/V ï¿½ï¿½ï¿½ï¿½ï¿½É‚Â‚ï¿½ï¿½ÄŽï¿½ï¿½?ï¿½Å‹È–ï¿½?ï¿½Ì“_ï¿½ï¿½?iï¿½Þ‘ï¿½ï¿½x Pu/Pv ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½Î’lï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½Â‚Ü‚ï¿½?Aï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ T ï¿½ï¿½ï¿½ï¿½?iï¿½Þ‚ï¿½?A
     * ï¿½ï¿½ï¿½?ï¿½Å‚Ì‹È–ï¿½?ï¿½Ì“_ï¿½ï¿½ U ï¿½ï¿½ï¿½Å‚ï¿½ Pu (scalingFactor[0])?A
     * V ï¿½ï¿½ï¿½Å‚ï¿½ Pv (scalingFactor[1]) ï¿½ï¿½ï¿½ï¿½?iï¿½Þ‚ï¿½ï¿½Æ‚ï¿½\ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?B
     * T ï¿½Ì‘å‚«ï¿½ï¿½ï¿½Í–ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½Ì‚ï¿½?Aï¿½ï¿½ï¿½Ì’lï¿½ï¿½Q?Æ‚ï¿½ï¿½ï¿½?Û‚É‚ï¿½?A
     * scalingFactor[0] ï¿½ï¿½ scalingFactor[1] ï¿½Ì”ä‚¾ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½ï¿½×‚ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½È‚ï¿½?Aï¿½ï¿½ï¿½ï¿½ï¿½Ì’lï¿½Í‚ï¿½ï¿½ï¿½ï¿½Ü‚Å‚ï¿½ÚˆÅ‚ï¿½ï¿½ï¿½?Aï¿½ï¿½ï¿½ï¿½ï¿½È‘ï¿½ï¿½xï¿½î¦‚ï¿½ï¿½ï¿½Ì‚Å‚Í‚È‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ Vector ï¿½ÉŠÜ‚Ü‚ï¿½ï¿½eï¿½vï¿½fï¿½ï¿½
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D
     * ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParameterSection U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vParameterSection V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tolerance         ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @param scalingFactor     ï¿½_ï¿½Qï¿½ï¿½Oï¿½pï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?Û‚É—Lï¿½pï¿½ÆŽvï¿½ï¿½ï¿½ï¿½ U/V ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½
     * @return ï¿½_ï¿½Qï¿½ï¿½Ü‚ï¿½ Vector
     * @see PointOnSurface3D
     */
    public Vector toNonStructuredPoints(ParameterSection uParameterSection,
                                        ParameterSection vParameterSection,
                                        double tolerance,
                                        double[] scalingFactor) {
        Vector result = new Vector();

        Mesh3D mesh = this.makeMesh(2, uParameterSection, vParameterSection,
                new ToleranceForDistance(tolerance));

        double uScale = 0.0;
        for (int u = 0; u < mesh.uNPoints(); u++) {
            if (u > 0)
                uScale += mesh.pointAt(u, 0).distance(mesh.pointAt((u - 1), 0));
            for (int v = 0; v < mesh.vNPoints(); v++)
                result.addElement(mesh.pointAt(u, v));
        }
        uScale /= uParameterSection.increase();

        scalingFactor[0] = uScale;
        scalingFactor[1] = 1.0;

        return result;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * transformedGeometries ï¿½ï¿½?A
     * ï¿½ÏŠï¿½ï¿½Oï¿½ÌŠô‰½—vï¿½fï¿½ï¿½L?[ï¿½Æ‚ï¿½?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½fï¿½ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½nï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?Û‚Éƒ?ï¿½\ï¿½bï¿½hï¿½Õ”ï¿½Å‚ï¿½ this ï¿½ï¿½L?[?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ê‚ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½ transformedGeometries ï¿½É’Ç‰Bï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉŠï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ï¿½ï¿½?Û‚Ì•ÏŠï¿½ï¿½ï¿½?sï¿½È‚í‚¸?Aï¿½ï¿½ï¿½ÌƒL?[ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½?Ä‹Aï¿½Iï¿½ï¿½?sï¿½È‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * transformedGeometries ï¿½ï¿½ null ï¿½Å‚ï¿½?\ï¿½ï¿½È‚ï¿½?B
     * transformedGeometries ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ?ï¿½ï¿½ this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param reverseTransform       ï¿½tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½Ì‚Å‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     * @param transformationOperator ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½q
     * @param transformedGeometries  ï¿½ï¿½É“ï¿½ï¿½lï¿½Ì•ÏŠï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ô‰½—vï¿½fï¿½ï¿½Ü‚Þƒnï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½
     * @return ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½f
     */
    protected synchronized ParametricSurface3D
    doTransformBy(boolean reverseTransform,
                  CartesianTransformationOperator3D transformationOperator,
                  java.util.Hashtable transformedGeometries) {
        ParametricCurve3D tSweptCurve =
                this.sweptCurve().transformBy(reverseTransform,
                        transformationOperator,
                        transformedGeometries);
        Vector3D tExtrusionAxis =
                this.extrusionAxis.transformBy(reverseTransform,
                        transformationOperator,
                        transformedGeometries);
        return new SurfaceOfLinearExtrusion3D(tSweptCurve, tExtrusionAxis);
    }

    /**
     * ?oï¿½ÍƒXï¿½gï¿½ï¿½?[ï¿½ï¿½ï¿½ÉŒ`?ï¿½?ï¿½ï¿½ï¿½?oï¿½Í‚ï¿½ï¿½ï¿½?B
     *
     * @param writer PrintWriter
     * @param indent ï¿½Cï¿½ï¿½ï¿½fï¿½ï¿½ï¿½gï¿½ï¿½?[ï¿½ï¿½
     * @see GeometryElement
     */
    protected void output(PrintWriter writer, int indent) {
        String indent_tab = makeIndent(indent);

        writer.println(indent_tab + getClassName());
        writer.println(indent_tab + "\tsweptCurve");
        sweptCurve().output(writer, indent + 2);
        writer.println(indent_tab + "\textrusionAxis");
        extrusionAxis.output(writer, indent + 2);
        writer.println(indent_tab + "End");
    }
}

