/*
 * JScience - Java(TM) Tools and Libraries for the Advancement of Sciences.
 * Copyright (C) 2025-2026 - Silvere Martin-Michiellot and Gemini AI (Google DeepMind)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.jscience.mathematics.geometry;

import java.util.Vector;

/**
 * ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½?ï¿½gï¿½ï¿½ï¿½bï¿½Nï¿½È‹È–Ê‚ÌƒNï¿½ï¿½ï¿½Xï¿½Kï¿½wï¿½Ìƒï¿½?[ï¿½gï¿½Æ‚È‚é’Š?ÛƒNï¿½ï¿½ï¿½X?B
 * <p/>
 * ï¿½ï¿½ï¿½ÌƒNï¿½ï¿½ï¿½Xï¿½ï¿½?Aï¿½ï¿½Â‚ÌŽï¿½?ï¿½ï¿½lï¿½Å•\ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Ì‘g (u, v) ï¿½Ì’lï¿½É‚ï¿½Bï¿½?A
 * ï¿½Ê’uï¿½ï¿½ï¿½ï¿½ï¿½è‚³ï¿½ï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½Ì‹È–ï¿½ P(u, v) ï¿½Sï¿½Ê‚ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?B
 * </p>
 *
 * @author Information-technology Promotion Agency, Japan
 * @version $Revision: 1.2 $, $Date: 2006/03/01 21:16:06 $
 */

public abstract class ParametricSurface3D extends AbstractParametricSurface {
    /**
     * ï¿½È–Ê‚ï¿½ Plane ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int PLANE_3D = 1;

    /**
     * ï¿½È–Ê‚ï¿½ Cylindrical Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int CYLINDRICAL_SURFACE_3D = 10;

    /**
     * ï¿½È–Ê‚ï¿½ Conical Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int CONICAL_SURFACE_3D = 11;

    /**
     * ï¿½È–Ê‚ï¿½ Spherical Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int SPHERICAL_SURFACE_3D = 12;

    /**
     * ï¿½È–Ê‚ï¿½ Surface Of Linear Extrusion ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int SURFACE_OF_LINEAR_EXTRUSION_3D = 20;

    /**
     * ï¿½È–Ê‚ï¿½ Surface Of Revolution ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int SURFACE_OF_REVOLUTION_3D = 21;

    /**
     * ï¿½È–Ê‚ï¿½ Bspline Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int BSPLINE_SURFACE_3D = 30;

    /**
     * ï¿½È–Ê‚ï¿½ Pure Bezier Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int PURE_BEZIER_SURFACE_3D = 31;

    /**
     * ï¿½È–Ê‚ï¿½ Rectangular Trimmed Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int RECTANGULAR_TRIMMED_SURFACE_3D = 32;

    /**
     * ï¿½È–Ê‚ï¿½ Curve Bounded Surface ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int CURVE_BOUNDED_SURFACE_3D = 33;

    /**
     * ï¿½È–Ê‚ï¿½ Mesh ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚î¦‚ï¿½ï¿½ï¿½?ï¿½
     */
    static final int MESH_3D = 40;

    /**
     * ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½ï¿½?\ï¿½zï¿½ï¿½ï¿½ï¿½?B
     */
    protected ParametricSurface3D() {
        super();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ï¿½?Wï¿½lï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @param uParam U ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?Wï¿½l
     */
    public abstract Point3D coordinates(double uParam, double vParam);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     * <p/>
     * ï¿½ï¿½ï¿½ï¿½ï¿½Å‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Æ‚ï¿½?Aï¿½pï¿½ï¿½ï¿½??[ï¿½^ U/V ï¿½ÌŠe?Xï¿½É‚Â‚ï¿½ï¿½Ä‚ÌˆêŽŸï¿½Î“ï¿½ï¿½ï¿½?ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½zï¿½ï¿½Ì—vï¿½f?ï¿½ï¿½ï¿½ 2 ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½zï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½Ì—vï¿½fï¿½É‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½?A
     * ï¿½ï¿½Ô–Ú‚Ì—vï¿½fï¿½É‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ü‚ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?Úƒxï¿½Nï¿½gï¿½ï¿½ï¿½Ì”zï¿½ï¿½
     */
    public abstract Vector3D[] tangentVector(double uParam, double vParam);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì–@?ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½ï¿½ï¿½Ô‚ï¿½ï¿½@?ï¿½xï¿½Nï¿½gï¿½ï¿½ï¿½ï¿½?A?ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½Pï¿½Êƒxï¿½Nï¿½gï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ?ï¿½ï¿½Kï¿½ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½@?ï¿½xï¿½Nï¿½gï¿½ï¿½
     */
    public Vector3D normalVector(double uParam, double vParam) {
        Vector3D[] tang;

        tang = tangentVector(uParam, vParam);
        return tang[0].crossProduct(tang[1]).unitized();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚ÌŽï¿½È—ï¿½?ï¿½ï¿½ï¿½Ô‚ï¿½?B
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½ï¿½È—ï¿½?ï¿½ï¿½
     */
    public SurfaceCurvature3D curvature(double uParam, double vParam) {
        SurfaceDerivative3D deriv;

        deriv = evaluation(uParam, vParam);
        return deriv.principalCurvature();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì•Î“ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½Î“ï¿½ï¿½ï¿½?ï¿½
     */
    public abstract SurfaceDerivative3D
    evaluation(double uParam, double vParam);

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ç‚±ï¿½Ì‹È–Ê‚Ö‚Ì“ï¿½ï¿½eï¿½_ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h?B
     * <p/>
     * ï¿½ï¿½ï¿½eï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param point ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_
     * @return ï¿½ï¿½ï¿½eï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    public abstract PointOnSurface3D[] projectFrom(Point3D point)
            throws IndefiniteSolutionException;

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ P ï¿½ï¿½ï¿½ç‚±ï¿½Ì‹È–Ê‚Ö‚Ì“ï¿½ï¿½eï¿½_ï¿½Ì“ï¿½ï¿½?AP ï¿½ï¿½?Å‚ï¿½ß‚ï¿½ï¿½_ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½eï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½ null ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param pnt ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_
     * @return ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_ï¿½ï¿½?Å‚ï¿½ß‚ï¿½ï¿½ï¿½ï¿½eï¿½_
     * @see #projectFrom(Point3D)
     * @see #nearestProjectWithDistanceFrom(Point3D,double)
     */
    public PointOnSurface3D nearestProjectFrom(Point3D pnt) {
        PointOnSurface3D[] proj;
        try {
            proj = projectFrom(pnt);
        } catch (IndefiniteSolutionException e) {
            proj = new PointOnSurface3D[1];
            proj[0] = (PointOnSurface3D) e.suitable();
        }

        if (proj.length == 0)
            return null;

        double dist = proj[0].distance2(pnt);
        int idx = 0;

        // find nearest point
        for (int i = 1; i < proj.length; i++) {
            double dist2 = proj[i].distance2(pnt);

            if (dist2 < dist) {
                dist = dist2;
                idx = i;
            }
        }

        return proj[idx];
    }

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ P ï¿½ï¿½ï¿½ç‚±ï¿½Ì‹È–Ê‚Ö‚Ì“ï¿½ï¿½eï¿½_ï¿½Ì“ï¿½ï¿½?AP ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½wï¿½ï¿½Ì’lï¿½ï¿½?Å‚ï¿½ß‚ï¿½ï¿½_ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½eï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½ null ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param pnt      ï¿½ï¿½ï¿½eï¿½ï¿½ï¿½Ì“_
     * @param distance ï¿½ï¿½ï¿½ï¿½
     * @return ï¿½wï¿½è‚µï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?Å‚ï¿½ß‚ï¿½ï¿½ï¿½ï¿½eï¿½_
     * @see #projectFrom(Point3D)
     * @see #nearestProjectFrom(Point3D)
     */
    public PointOnSurface3D nearestProjectWithDistanceFrom(Point3D pnt, double distance) {
        PointOnSurface3D[] proj;
        try {
            proj = projectFrom(pnt);
        } catch (IndefiniteSolutionException e) {
            proj = new PointOnSurface3D[1];
            proj[0] = (PointOnSurface3D) e.suitable();
        }

        if (proj.length == 0)
            return null;

        double diff = Math.abs(distance - proj[0].distance(pnt));
        int idx = 0;

        // find nearest point
        for (int i = 1; i < proj.length; i++) {
            double diff2 = Math.abs(distance - proj[i].distance(pnt));

            if (diff2 < diff) {
                diff = diff2;
                idx = i;
            }
        }

        return proj[idx];
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Qï¿½ï¿½?\?ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D ï¿½ï¿½
     * ï¿½ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tol   ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ð•½–Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½iï¿½qï¿½_ï¿½Q
     * @see PointOnSurface3D
     */
    public abstract Mesh3D
    toMesh(ParameterSection uPint, ParameterSection vPint,
           ToleranceForDistance tol);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ìµ–ï¿½ï¿½ï¿½?ÄŒï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½Lï¿½? Bspline ï¿½È–Ê‚ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½Ô‚ï¿½?ÄŒï¿½ï¿½ï¿½ï¿½ï¿½Lï¿½? Bspline ï¿½È–ï¿½
     */
    public abstract BsplineSurface3D
    toBsplineSurface(ParameterSection uPint,
                     ParameterSection vPint);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    public abstract IntersectionPoint3D[]
    intersect(ParametricCurve3D mate)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    abstract IntersectionPoint3D[]
    intersect(Line3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½~??ï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½~??ï¿½ï¿½?ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    abstract IntersectionPoint3D[]
    intersect(Conic3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½ (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     */
    IntersectionPoint3D[] intersect(Polyline3D mate, boolean doExchange) {
        return mate.intersect(this, !doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½xï¿½Wï¿½Gï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½xï¿½Wï¿½Gï¿½ï¿½?ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    abstract IntersectionPoint3D[]
    intersect(PureBezierCurve3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½?ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     */
    abstract IntersectionPoint3D[]
    intersect(BsplineCurve3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½ (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½gï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     */
    IntersectionPoint3D[] intersect(TrimmedCurve3D mate, boolean doExchange) {
        return mate.intersect(this, !doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½ï¿½ï¿½?ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½ (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½ï¿½ï¿½?ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     */
    IntersectionPoint3D[] intersect(CompositeCurve3D mate, boolean doExchange) {
        return mate.intersect(this, !doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½ï¿½ï¿½?ï¿½Zï¿½Oï¿½?ï¿½ï¿½ï¿½g) ï¿½ÌŒï¿½_ï¿½ï¿½?ï¿½ß‚ï¿½ (internal use) ?B
     * <p/>
     * ï¿½ï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹ï¿½?ï¿½ (ï¿½ï¿½?ï¿½ï¿½ï¿½?ï¿½Zï¿½Oï¿½?ï¿½ï¿½ï¿½g)
     * @param doExchange ï¿½ï¿½_ï¿½ï¿½ pointOnGeometry1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Ì”zï¿½ï¿½
     */
    IntersectionPoint3D[] intersect(CompositeCurveSegment3D mate, boolean doExchange) {
        return mate.intersect(this, !doExchange);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–Ê‚Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate ï¿½ï¿½ï¿½Ì‹È–ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    public abstract SurfaceSurfaceInterference3D[]
    intersect(ParametricSurface3D mate)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½) ï¿½Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    abstract SurfaceSurfaceInterference3D[]
    intersect(Plane3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½) ï¿½Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    abstract SurfaceSurfaceInterference3D[]
    intersect(SphericalSurface3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~ï¿½ï¿½ï¿½ï¿½) ï¿½Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~ï¿½ï¿½ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    abstract SurfaceSurfaceInterference3D[]
    intersect(CylindricalSurface3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~??ï¿½ï¿½) ï¿½Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½~??ï¿½ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½âª•sï¿½ï¿½Å‚ï¿½ï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    abstract SurfaceSurfaceInterference3D[]
    intersect(ConicalSurface3D mate, boolean doExchange)
            throws IndefiniteSolutionException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½xï¿½Wï¿½Gï¿½È–ï¿½) ï¿½Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½xï¿½Wï¿½Gï¿½È–ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    abstract SurfaceSurfaceInterference3D[]
    intersect(PureBezierSurface3D mate, boolean doExchange);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½È–ï¿½) ï¿½Æ‚ÌŒï¿½?ï¿½ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h (internal use) ?B
     * <p/>
     * ï¿½ï¿½?ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½Æ‚ï¿½ï¿½Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½?ï¿½ (IntersectionCurve3D) ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½È–Ê‚ï¿½?Ú‚ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½É‚Â‚ï¿½ï¿½Ä‚ï¿½?Aï¿½ï¿½_ (IntersectionPoint3D) ï¿½ï¿½ï¿½Ô‚é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½aï¿½Xï¿½vï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½È–ï¿½)
     * @param doExchange ï¿½ï¿½?ï¿½ï¿½ basisSurface1/2 ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½?ï¿½ (ï¿½Ü‚ï¿½ï¿½ÍŒï¿½_) ï¿½Ì”zï¿½ï¿½
     * @see IntersectionCurve3D
     * @see IntersectionPoint3D
     */
    abstract SurfaceSurfaceInterference3D[]
    intersect(BsplineSurface3D mate, boolean doExchange);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½ï¿½ï¿½ï¿½È–Ê‚ï¿½
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½ Bspline ï¿½È–Ê‚ï¿½?ï¿½ß‚é’Š?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @param uPint U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vPint V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param magni ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ï¿½
     * @param side  ï¿½Iï¿½tï¿½Zï¿½bï¿½gï¿½ÌŒï¿½ (WhichSide.FRONT/BACK)
     * @param tol   ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @return ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½Ì‹ï¿½`ï¿½ï¿½Ô‚ÌƒIï¿½tï¿½Zï¿½bï¿½gï¿½È–Ê‚ï¿½ßŽï¿½ï¿½ï¿½ï¿½ï¿½ Bspline ï¿½È–ï¿½
     * @see WhichSide
     */
    public abstract BsplineSurface3D
    offsetByBsplineSurface(ParameterSection uSect,
                           ParameterSection vSect,
                           double magni,
                           int side,
                           ToleranceForDistance tol);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?A
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚É‚ï¿½ï¿½ï¿½ï¿½ï¿½tï¿½Bï¿½ï¿½ï¿½bï¿½gï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½tï¿½Bï¿½ï¿½ï¿½bï¿½gï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚Í’ï¿½ï¿½ï¿½ 0 ï¿½Ì”zï¿½ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param uSect1 ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vSect1 ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param side1  ï¿½ï¿½ï¿½Ì‹È–Ê‚Ì‚Ç‚ï¿½ï¿½ç‘¤ï¿½Éƒtï¿½Bï¿½ï¿½ï¿½bï¿½gï¿½ï¿½?ï¿½ß‚é‚©ï¿½î¦‚ï¿½ï¿½tï¿½ï¿½ï¿½O
     *               (WhichSide.FRONTï¿½È‚ï¿½Î•\ï¿½ï¿½?ARIGHTï¿½È‚ï¿½Î—ï¿½ï¿½ï¿½?ABOTHï¿½È‚ï¿½Î—ï¿½ï¿½ï¿½)
     * @param mate   ï¿½ï¿½ï¿½Ì‹È–ï¿½
     * @param uSect2 ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vSect2 ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param side2  ï¿½ï¿½ï¿½Ì‹È–Ê‚Ì‚Ç‚ï¿½ï¿½ç‘¤ï¿½Éƒtï¿½Bï¿½ï¿½ï¿½bï¿½gï¿½ï¿½?ï¿½ß‚é‚©ï¿½î¦‚ï¿½ï¿½tï¿½ï¿½ï¿½O
     *               (WhichSide.FRONTï¿½È‚ï¿½Î•\ï¿½ï¿½?ARIGHTï¿½È‚ï¿½Î—ï¿½ï¿½ï¿½?ABOTHï¿½È‚ï¿½Î—ï¿½ï¿½ï¿½)
     * @param radius ï¿½tï¿½Bï¿½ï¿½ï¿½bï¿½gï¿½ï¿½ï¿½a
     * @return ï¿½tï¿½Bï¿½ï¿½ï¿½bï¿½gï¿½Ì”zï¿½ï¿½
     * @throws IndefiniteSolutionException ï¿½ï¿½sï¿½ï¿½ (ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?ï¿½Å‚Í”ï¿½?ï¿½ï¿½ï¿½ï¿½È‚ï¿½)
     * @see WhichSide
     */
    public FilletObject3D[]
    fillet(ParameterSection uSect1, ParameterSection vSect1, int side1,
           ParametricSurface3D mate,
           ParameterSection uSect2, ParameterSection vSect2, int side2,
           double radius)
            throws IndefiniteSolutionException {
        return FiltSrfSrf3D.fillet(this, uSect1, vSect1, side1,
                mate, uSect2, vSect2, side2, radius);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½é“™ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @param uParam U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½wï¿½ï¿½ï¿½ U ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì“ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½
     */
    public abstract ParametricCurve3D uIsoParametricCurve(double uParam)
            throws ReducedToPointException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½ÌˆÊ’uï¿½É‚ï¿½ï¿½é“™ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @param vParam V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l
     * @return ï¿½wï¿½ï¿½ï¿½ V ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Å‚Ì“ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?ï¿½
     */
    public abstract ParametricCurve3D vIsoParametricCurve(double vParam)
            throws ReducedToPointException;

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ?ï¿½ï¿½ 3 ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @return ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½È‚Ì‚ï¿½?A?ï¿½ï¿½ 3
     */
    public int dimension() {
        return 3;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Û‚ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * <p/>
     * ?ï¿½ï¿½ true ï¿½ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @return ï¿½Rï¿½ï¿½ï¿½ï¿½ï¿½È‚Ì‚ï¿½?A?ï¿½ï¿½ true
     */
    public boolean is3D() {
        return true;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Ì—vï¿½fï¿½ï¿½Ê‚ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     *
     * @return ï¿½vï¿½fï¿½ï¿½ï¿½
     * @see #PLANE_3D
     * @see #CYLINDRICAL_SURFACE_3D
     * @see #CONICAL_SURFACE_3D
     * @see #SPHERICAL_SURFACE_3D
     * @see #SURFACE_OF_LINEAR_EXTRUSION_3D
     * @see #SURFACE_OF_REVOLUTION_3D
     * @see #BSPLINE_SURFACE_3D
     * @see #PURE_BEZIER_SURFACE_3D
     * @see #RECTANGULAR_TRIMMED_SURFACE_3D
     * @see #CURVE_BOUNDED_SURFACE_3D
     * @see #MESH_3D
     */
    abstract int type();

    /**
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½_ï¿½ï¿½?Aï¿½ï¿½ï¿½Ì‹È–Ê‚Å‚Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½ï¿½?ï¿½ß‚ï¿½?B
     * <p/>
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹È–ï¿½?ï¿½ï¿½?ï¿½BÄ‚ï¿½ï¿½ï¿½ï¿½Ì‚Æ‚ï¿½ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ì“_ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½l (u, v) ï¿½ï¿½?ï¿½ß‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½Ì“Õ”?ï¿½ï¿½?ï¿½ÍˆÈ‰ï¿½ï¿½Ì’Ê‚ï¿½?B
     * <ul>
     * <li> nearestProjectFrom(pnt) ï¿½ï¿½gï¿½Bï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ P ï¿½ï¿½?Å‚ï¿½ß‚ï¿½ï¿½ï¿½ï¿½eï¿½_ Q ï¿½ð“¾‚ï¿½
     * <li> ï¿½ï¿½ï¿½eï¿½_ï¿½ï¿½ï¿½ï¿½?Ý‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½Í‚ï¿½ï¿½Ì‹È–Ê‚ï¿½?ï¿½BÄ‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½Ì‚Æ‚ï¿½ï¿½ï¿½Oï¿½ð“Š‚ï¿½ï¿½ï¿½
     * <li> P ï¿½ï¿½ Q ï¿½ï¿½ï¿½ï¿½?ï¿½?Ý’è‚³ï¿½ï¿½Ä‚ï¿½ï¿½é‰‰ï¿½Z?ï¿½?ï¿½ï¿½ï¿½Å“ï¿½ï¿½ï¿½Ì“_ï¿½Æ‚Ý‚È‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½Í‚ï¿½ï¿½Ì‹È–Ê‚ï¿½?ï¿½BÄ‚ï¿½ï¿½È‚ï¿½ï¿½ï¿½Ì‚Æ‚ï¿½ï¿½ï¿½Oï¿½ð“Š‚ï¿½ï¿½ï¿½
     * <li> Q ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l (u, v) ï¿½ï¿½Ô‚ï¿½
     * </ul>
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½zï¿½ï¿½Ì—vï¿½f?ï¿½ï¿½ï¿½ 2 ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½zï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½Ì—vï¿½fï¿½ï¿½ U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½l?A
     * ï¿½ï¿½Ô–Ú‚Ì—vï¿½fï¿½ï¿½ V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½ï¿½Ü‚ï¿½?B
     * </p>
     *
     * @param pnt ï¿½È–ï¿½?ï¿½Ì“_
     * @return ï¿½Î‰ï¿½ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½Ì”zï¿½ï¿½ (u, v)
     * @throws InvalidArgumentValueException ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?ï¿½BÄ‚ï¿½ï¿½È‚ï¿½
     * @see #nearestProjectFrom(Point3D)
     * @see ConditionOfOperation
     */
    public double[] pointToParameter(Point3D pnt) {
        PointOnSurface3D proj = nearestProjectFrom(pnt);
        if (proj == null)
            throw new InvalidArgumentValueException();

        if (pnt.identical(proj))
            return proj.parameters();
        else
            throw new InvalidArgumentValueException();
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚Æ‘ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½?Í‹È–ï¿½) ï¿½ÌŒï¿½_ï¿½ï¿½?Wï¿½lï¿½ï¿½?Aï¿½ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½gï¿½É•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½Ì“Õ”ï¿½Å‚ï¿½?A
     * this ï¿½ï¿½ mate ï¿½Ì‚ï¿½ï¿½ê‚¼ï¿½ï¿½É‚Â‚ï¿½ï¿½ï¿½ pointToParameter(Point3D) ï¿½ï¿½Ä‚ï¿½?oï¿½ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½lï¿½ð“¾‚Ä‚ï¿½ï¿½ï¿½?B
     * ï¿½È‚ï¿½?ApointToParameter(Point3D) ï¿½ï¿½
     * InvalidArgumentValueException ï¿½Ì—ï¿½Oï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½ï¿½ï¿½é‚ª?A
     * ï¿½ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½Ì“Õ”ï¿½Å‚Í‚ï¿½ï¿½ï¿½ï¿½ catch ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½È‚ï¿½?B
     * </p>
     *
     * @param point      ï¿½ï¿½_ï¿½ï¿½\ï¿½ï¿½?Wï¿½l
     * @param mate       ï¿½ï¿½ï¿½Ì‹È–ï¿½ (ï¿½ï¿½?Í‹È–ï¿½)
     * @param doExchange ï¿½ï¿½_ï¿½ÌŠiï¿½[?ï¿½ï¿½ï¿½ê·‚ï¿½ï¿½é‚©ï¿½Ç‚ï¿½ï¿½ï¿½
     * @return ï¿½ï¿½_ï¿½Iï¿½uï¿½Wï¿½Fï¿½Nï¿½g
     * @throws InvalidArgumentValueException ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½_ï¿½ï¿½ï¿½Ç‚ï¿½ï¿½ç‚©ï¿½Ì‹È–Ê‚ï¿½?ï¿½BÄ‚ï¿½ï¿½È‚ï¿½
     * @see #pointToParameter(Point3D)
     */
    IntersectionPoint3D pointToIntersectionPoint(Point3D point,
                                                 ElementarySurface3D mate,
                                                 boolean doExchange) {
        double[] thisParams = this.pointToParameter(point);
        double[] mateParams = mate.pointToParameter(point);
        if (!doExchange)
            return new IntersectionPoint3D(point,
                    this, thisParams[0], thisParams[1],
                    mate, mateParams[0], mateParams[1],
                    doCheckDebug);
        else
            return new IntersectionPoint3D(point,
                    mate, mateParams[0], mateParams[1],
                    this, thisParams[0], thisParams[1],
                    doCheckDebug);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ï¿½ï¿½ï¿½Iï¿½ï¿½ (ï¿½Â‚ï¿½ï¿½ï¿½) ï¿½È–Ê‚Å‚ï¿½ï¿½ï¿½ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½?ï¿½Ì“_ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½ U/V ï¿½ï¿½ï¿½ï¿½ï¿½ÉŽï¿½ï¿½Iï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½Í‰ï¿½ï¿½Âµï¿½È‚ï¿½?B
     * </p>
     * <p/>
     * pnts ï¿½É—^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½Qï¿½ï¿½ï¿½ï¿½ï¿½Ì“_ï¿½ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½ÌŽï¿½ï¿½Iï¿½È‹È–Ê‚Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½?ï¿½Ìƒ|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ÆŒï¿½ï¿½È‚ï¿½?A
     * ï¿½ï¿½ï¿½Ìƒ|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½È–Ê‚ÌŽï¿½ï¿½ÌŒqï¿½ï¿½ï¿½Ú‚Ì“_ï¿½ï¿½Ü‚ï¿½Å‚ï¿½ï¿½ï¿½Æ‚ï¿½ï¿½ï¿½?A
     * ï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ì‚ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½ï¿½ï¿½?A
     * ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ÌŽï¿½ï¿½ÌŒqï¿½ï¿½ï¿½Ú‚ï¿½×‚ï¿½ï¿½ï¿½?Lï¿½Ñ‚Ä‚ï¿½ï¿½ï¿½ï¿½?lï¿½ï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½Ì’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Zï¿½ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½ï¿½?A
     * ï¿½ï¿½ï¿½ÌŽï¿½ï¿½ÌŒqï¿½ï¿½ï¿½Ú‚ï¿½×‚ï¿½ï¿½æ‚¤ï¿½Éƒ|ï¿½ï¿½ï¿½ï¿½ï¿½Cï¿½ï¿½ï¿½ÌŠeï¿½_ï¿½Ì’lï¿½ï¿½ï¿½?Xï¿½ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * pnts ï¿½ï¿½ÌŠeï¿½vï¿½fï¿½Í‚ï¿½ï¿½Ìƒ?ï¿½\ï¿½bï¿½hï¿½Ì“Õ”ï¿½Å•ï¿½?Xï¿½ï¿½ï¿½ï¿½é‚©ï¿½Âµï¿½ï¿½È‚ï¿½?B
     * </p>
     *
     * @param pnts ï¿½Qï¿½ï¿½ï¿½ï¿½ï¿½Ì“_ï¿½Ì”zï¿½ï¿½
     */
    void confirmConnectionOfPointsOnSurface(Point2D[] pnts) {
        int uip = pnts.length;
        double width;
        double val_i, val_j;
        double gap0, gapm, gapp;
        int i, j;

        if (isUFinite() && isUPeriodic()) {
            width = uParameterDomain().section().absIncrease();
            for (i = 0, j = 1; j < uip; i++, j++) {
                val_i = pnts[i].x();
                val_j = pnts[j].x();
                gap0 = Math.abs(val_j - val_i);
                gapm = Math.abs(val_j - width - val_i);
                gapp = Math.abs(val_j + width - val_i);
                if (gapm < gapp) {
                    if (gapm < gap0)
                        pnts[j] = new CartesianPoint2D(pnts[j].x() - width, pnts[j].y());
                } else {
                    if (gapp < gap0)
                        pnts[j] = new CartesianPoint2D(pnts[j].x() + width, pnts[j].y());
                }
            }
        }

        if (isVFinite() && isVPeriodic()) {
            width = vParameterDomain().section().absIncrease();
            for (i = 0, j = 1; j < uip; i++, j++) {
                val_i = pnts[i].y();
                val_j = pnts[j].y();
                gap0 = Math.abs(val_j - val_i);
                gapm = Math.abs(val_j - width - val_i);
                gapp = Math.abs(val_j + width - val_i);
                if (gapm < gapp) {
                    if (gapm < gap0)
                        pnts[j] = new CartesianPoint2D(pnts[j].x(), pnts[j].y() - width);
                } else {
                    if (gapp < gap0)
                        pnts[j] = new CartesianPoint2D(pnts[j].x(), pnts[j].y() + width);
                }
            }
        }
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ÌŽwï¿½ï¿½ï¿½ (ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½Iï¿½ï¿½) ï¿½ï¿½`ï¿½ï¿½Ô‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ï¿½?ï¿½ï¿½Å•ï¿½ï¿½Ê‹ßŽï¿½ï¿½ï¿½ï¿½ï¿½
     * ï¿½_ï¿½Qï¿½ï¿½Ô‚ï¿½ï¿½ï¿½?Ûƒ?ï¿½\ï¿½bï¿½h?B
     * <p/>
     * ?ï¿½ï¿½?ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä“ï¿½ï¿½ï¿½ï¿½ï¿½_ï¿½Qï¿½Íˆï¿½Ê‚ï¿½?Aï¿½Ê‘ï¿½ï¿½Iï¿½É‚ï¿½ô‰½“Iï¿½É‚ï¿½?Aï¿½iï¿½q?ï¿½Å‚Í‚È‚ï¿½?B
     * </p>
     * <p/>
     * scalingFactor ï¿½ï¿½?Aï¿½ï¿½Í—pï¿½Å‚Í‚È‚ï¿½?A?oï¿½Í—pï¿½Ìˆï¿½?ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * scalingFactor ï¿½É‚ï¿½?Aï¿½vï¿½f?ï¿½ 2 ï¿½Ì”zï¿½ï¿½ï¿½^ï¿½ï¿½ï¿½ï¿½?B
     * scalingFactor[0] ï¿½É‚ï¿½ U ï¿½ï¿½ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½?A
     * scalingFactor[1] ï¿½É‚ï¿½ V ï¿½ï¿½ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½ï¿½ï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½ï¿½Ì’lï¿½Í‰ï¿½ï¿½ç‚©ï¿½ï¿½?ï¿½Î’lï¿½Å‚Í‚È‚ï¿½?A
     * ï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½?iï¿½Þ‘ï¿½ï¿½x T ï¿½É‘Î‚ï¿½ï¿½ï¿½?A
     * U/V ï¿½ï¿½ï¿½ï¿½ï¿½É‚Â‚ï¿½ï¿½ÄŽï¿½ï¿½?ï¿½Å‹È–ï¿½?ï¿½Ì“_ï¿½ï¿½?iï¿½Þ‘ï¿½ï¿½x Pu/Pv ï¿½ï¿½\ï¿½ï¿½ï¿½ï¿½ï¿½Î’lï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½Â‚Ü‚ï¿½?Aï¿½pï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ T ï¿½ï¿½ï¿½ï¿½?iï¿½Þ‚ï¿½?A
     * ï¿½ï¿½ï¿½?ï¿½Å‚Ì‹È–ï¿½?ï¿½Ì“_ï¿½ï¿½ U ï¿½ï¿½ï¿½Å‚ï¿½ Pu (scalingFactor[0])?A
     * V ï¿½ï¿½ï¿½Å‚ï¿½ Pv (scalingFactor[1]) ï¿½ï¿½ï¿½ï¿½?iï¿½Þ‚ï¿½ï¿½Æ‚ï¿½\ï¿½ï¿½ï¿½Ä‚ï¿½ï¿½ï¿½?B
     * T ï¿½Ì‘å‚«ï¿½ï¿½ï¿½Í–ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½È‚ï¿½ï¿½Ì‚ï¿½?Aï¿½ï¿½ï¿½Ì’lï¿½ï¿½Q?Æ‚ï¿½ï¿½ï¿½?Û‚É‚ï¿½?A
     * scalingFactor[0] ï¿½ï¿½ scalingFactor[1] ï¿½Ì”ä‚¾ï¿½ï¿½ï¿½ï¿½pï¿½ï¿½ï¿½ï¿½×‚ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * ï¿½È‚ï¿½?Aï¿½ï¿½ï¿½ï¿½ï¿½Ì’lï¿½Í‚ï¿½ï¿½ï¿½ï¿½Ü‚Å‚ï¿½ÚˆÅ‚ï¿½ï¿½ï¿½?Aï¿½ï¿½ï¿½ï¿½ï¿½È‘ï¿½ï¿½xï¿½î¦‚ï¿½ï¿½ï¿½Ì‚Å‚Í‚È‚ï¿½?B
     * </p>
     * <p/>
     * ï¿½ï¿½ï¿½Ê‚Æ‚ï¿½ï¿½Ä•Ô‚ï¿½ Vector ï¿½ÉŠÜ‚Ü‚ï¿½ï¿½eï¿½vï¿½fï¿½ï¿½
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½x?[ï¿½Xï¿½Æ‚ï¿½ï¿½ï¿½ PointOnSurface3D
     * ï¿½Å‚ï¿½ï¿½é‚±ï¿½Æ‚ï¿½ï¿½ï¿½Ò‚Å‚ï¿½ï¿½ï¿½?B
     * </p>
     *
     * @param uParameterSection U ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param vParameterSection V ï¿½ï¿½ï¿½Ìƒpï¿½ï¿½ï¿½??[ï¿½^ï¿½ï¿½ï¿½
     * @param tolerance         ï¿½ï¿½ï¿½ï¿½ï¿½Ì‹ï¿½ï¿½eï¿½ï¿½?ï¿½
     * @param scalingFactor     ï¿½_ï¿½Qï¿½ï¿½Oï¿½pï¿½`ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½?Û‚É—Lï¿½pï¿½ÆŽvï¿½ï¿½ï¿½ï¿½ U/V ï¿½ï¿½?kï¿½Ú”{ï¿½ï¿½
     * @return ï¿½_ï¿½Qï¿½ï¿½Ü‚ï¿½ Vector
     * @see PointOnSurface3D
     */
    public abstract Vector toNonStructuredPoints(ParameterSection uParameterSection,
                                                 ParameterSection vParameterSection,
                                                 double tolerance,
                                                 double[] scalingFactor);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * transformedGeometries ï¿½ï¿½?A
     * ï¿½ÏŠï¿½ï¿½Oï¿½ÌŠô‰½—vï¿½fï¿½ï¿½L?[ï¿½Æ‚ï¿½?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½fï¿½ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½nï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?Û‚Éƒ?ï¿½\ï¿½bï¿½hï¿½Õ”ï¿½Å‚ï¿½ this ï¿½ï¿½L?[?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ê‚ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½ transformedGeometries ï¿½É’Ç‰Bï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉŠï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ï¿½ï¿½?Û‚Ì•ÏŠï¿½ï¿½ï¿½?sï¿½È‚í‚¸?Aï¿½ï¿½ï¿½ÌƒL?[ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½?Ä‹Aï¿½Iï¿½ï¿½?sï¿½È‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * transformedGeometries ï¿½ï¿½ null ï¿½Å‚ï¿½?\ï¿½ï¿½È‚ï¿½?B
     * transformedGeometries ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ?ï¿½ï¿½ this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param reverseTransform       ï¿½tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½Ì‚Å‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     * @param transformationOperator ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½q
     * @param transformedGeometries  ï¿½ï¿½É“ï¿½ï¿½lï¿½Ì•ÏŠï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ô‰½—vï¿½fï¿½ï¿½Ü‚Þƒnï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½
     * @return ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½f
     */
    protected abstract ParametricSurface3D
    doTransformBy(boolean reverseTransform,
                  CartesianTransformationOperator3D transformationOperator,
                  java.util.Hashtable transformedGeometries);

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * transformedGeometries ï¿½ï¿½?A
     * ï¿½ÏŠï¿½ï¿½Oï¿½ÌŠô‰½—vï¿½fï¿½ï¿½L?[ï¿½Æ‚ï¿½?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½fï¿½ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½nï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?Û‚Éƒ?ï¿½\ï¿½bï¿½hï¿½Õ”ï¿½Å‚ï¿½ this ï¿½ï¿½L?[?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ê‚ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½ transformedGeometries ï¿½É’Ç‰Bï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉŠï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ï¿½ï¿½?Û‚Ì•ÏŠï¿½ï¿½ï¿½?sï¿½È‚í‚¸?Aï¿½ï¿½ï¿½ÌƒL?[ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½?Ä‹Aï¿½Iï¿½ï¿½?sï¿½È‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * transformedGeometries ï¿½ï¿½ null ï¿½Å‚ï¿½?\ï¿½ï¿½È‚ï¿½?B
     * transformedGeometries ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ?ï¿½ï¿½ this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param reverseTransform       ï¿½tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½Ì‚Å‚ï¿½ï¿½ï¿½ï¿½ true?Aï¿½ï¿½ï¿½ï¿½ï¿½Å‚È‚ï¿½ï¿½ï¿½ï¿½ false
     * @param transformationOperator ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½q
     * @param transformedGeometries  ï¿½ï¿½É“ï¿½ï¿½lï¿½Ì•ÏŠï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ô‰½—vï¿½fï¿½ï¿½Ü‚Þƒnï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½
     * @return ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½f
     */
    public synchronized ParametricSurface3D
    transformBy(boolean reverseTransform,
                CartesianTransformationOperator3D transformationOperator,
                java.util.Hashtable transformedGeometries) {
        if (transformedGeometries == null)
            return this.doTransformBy(reverseTransform,
                    transformationOperator,
                    transformedGeometries);

        ParametricSurface3D transformed = (ParametricSurface3D) transformedGeometries.get(this);
        if (transformed == null) {
            transformed = this.doTransformBy(reverseTransform,
                    transformationOperator,
                    transformedGeometries);
            transformedGeometries.put(this, transformed);
        }
        return transformed;
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * transformedGeometries ï¿½ï¿½?A
     * ï¿½ÏŠï¿½ï¿½Oï¿½ÌŠô‰½—vï¿½fï¿½ï¿½L?[ï¿½Æ‚ï¿½?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½fï¿½ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½nï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?Û‚Éƒ?ï¿½\ï¿½bï¿½hï¿½Õ”ï¿½Å‚ï¿½ this ï¿½ï¿½L?[?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ê‚ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½ transformedGeometries ï¿½É’Ç‰Bï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉŠï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ï¿½ï¿½?Û‚Ì•ÏŠï¿½ï¿½ï¿½?sï¿½È‚í‚¸?Aï¿½ï¿½ï¿½ÌƒL?[ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½?Ä‹Aï¿½Iï¿½ï¿½?sï¿½È‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * transformedGeometries ï¿½ï¿½ null ï¿½Å‚ï¿½?\ï¿½ï¿½È‚ï¿½?B
     * transformedGeometries ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ?ï¿½ï¿½ this ï¿½ï¿½ transformationOperator ï¿½Å•ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param transformationOperator ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½q
     * @param transformedGeometries  ï¿½ï¿½É“ï¿½ï¿½lï¿½Ì•ÏŠï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ô‰½—vï¿½fï¿½ï¿½Ü‚Þƒnï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½
     * @return ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½f
     */
    public synchronized ParametricSurface3D
    transformBy(CartesianTransformationOperator3D transformationOperator,
                java.util.Hashtable transformedGeometries) {
        return transformBy(false, transformationOperator, transformedGeometries);
    }

    /**
     * ï¿½ï¿½ï¿½Ì‹È–Ê‚ï¿½?Aï¿½^ï¿½ï¿½ï¿½ï¿½ê‚½ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½qï¿½Å‹tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½?B
     * <p/>
     * transformedGeometries ï¿½ï¿½?A
     * ï¿½ÏŠï¿½ï¿½Oï¿½ÌŠô‰½—vï¿½fï¿½ï¿½L?[ï¿½Æ‚ï¿½?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½fï¿½ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½nï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½ï¿½Å‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½È‚ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * this ï¿½ï¿½ transformationOperator ï¿½Å‹tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?Û‚Éƒ?ï¿½\ï¿½bï¿½hï¿½Õ”ï¿½Å‚ï¿½ this ï¿½ï¿½L?[?A
     * ï¿½ÏŠï¿½ï¿½ï¿½ï¿½Ê‚ï¿½lï¿½Æ‚ï¿½ï¿½ï¿½ transformedGeometries ï¿½É’Ç‰Bï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * this ï¿½ï¿½ transformedGeometries ï¿½ï¿½ÉŠï¿½ÉƒL?[ï¿½Æ‚ï¿½ï¿½Ä‘ï¿½?Ý‚ï¿½ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ï¿½ï¿½?Û‚Ì•ÏŠï¿½ï¿½ï¿½?sï¿½È‚í‚¸?Aï¿½ï¿½ï¿½ÌƒL?[ï¿½É‘Î‰ï¿½ï¿½ï¿½ï¿½ï¿½lï¿½ï¿½Ô‚ï¿½?B
     * ï¿½ï¿½ï¿½ï¿½?ï¿½ï¿½?ï¿½ï¿½?Ä‹Aï¿½Iï¿½ï¿½?sï¿½È‚ï¿½ï¿½ï¿½?B
     * </p>
     * <p/>
     * transformedGeometries ï¿½ï¿½ null ï¿½Å‚ï¿½?\ï¿½ï¿½È‚ï¿½?B
     * transformedGeometries ï¿½ï¿½ null ï¿½ï¿½?ï¿½?ï¿½ï¿½É‚ï¿½?A
     * ?ï¿½ï¿½ this ï¿½ï¿½ transformationOperator ï¿½Å‹tï¿½ÏŠï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ì‚ï¿½Ô‚ï¿½?B
     * </p>
     *
     * @param transformationOperator ï¿½ô‰½“Iï¿½ÏŠï¿½ï¿½ï¿½ï¿½Zï¿½q
     * @param transformedGeometries  ï¿½ï¿½É“ï¿½ï¿½lï¿½Ì•ÏŠï¿½ï¿½ï¿½{ï¿½ï¿½ï¿½ï¿½ï¿½ô‰½—vï¿½fï¿½ï¿½Ü‚Þƒnï¿½bï¿½Vï¿½ï¿½ï¿½e?[ï¿½uï¿½ï¿½
     * @return ï¿½tï¿½ÏŠï¿½ï¿½ï¿½ÌŠô‰½—vï¿½f
     */
    public synchronized ParametricSurface3D
    reverseTransformBy(CartesianTransformationOperator3D transformationOperator,
                       java.util.Hashtable transformedGeometries) {
        return transformBy(true, transformationOperator, transformedGeometries);
    }
}

