/* BlackboardLevel.java */
package org.jscience.computing.ai.blackboard;

import org.jscience.computing.ai.blackboard.util.AVLTree;
import org.jscience.computing.ai.blackboard.util.IndexAllocator;
import org.jscience.computing.ai.blackboard.util.ValuePair;

import java.util.BitSet;
import java.util.Hashtable;


/**
 * BlackboardLevel class.  Every blackboard entry is associated with a
 * particular blackboard level.  A blackboard level defines a template for
 * it's contained entries and provides a pattern matching interface for
 * accessing them.  The creation, deletion and modification of an entry is
 * reported to observers of this level.
 *
 * @author:   Paul Brown
 * @version:  1.6, 04/26/96
 *
 * @see java.util.Observable#addObserver
 */

// The author allowed us to redistribute this program under GPL:
// name: Alun Preece
// email: A.D.Preece@cs.cardiff.ac.uk
// website: http://www.csd.abdn.ac.uk/~apreece/pbf/ or http://users.cs.cf.ac.uk/A.D.Preece/
public class BlackboardLevel extends java.util.Observable {
    /** Default values for attributes of this level. */
    private ValuePair[] defaults;

    /** This table is used for matching attribute values to entries. */
    private Hashtable matching_table;

    /** These are the entries contained on this level. */
    private AVLTree entries;

    /**
     * At creation each entry is assigned a unique identifier (within
     * the context of this level) generated by this index allocator.
     */
    private IndexAllocator indexer;

/**
         * Constructs a new blackboard level, initialising attribute default
         * values to those specified.
         * @param defaults the default values for entry attributes
         */
    public BlackboardLevel(ValuePair[] defaults) {
        this.defaults = defaults;
        matching_table = new Hashtable(defaults.length, 1.0f);

        for (int i = 0; i < defaults.length; i++)
            matching_table.put(defaults[i].key(), new AVLTree());

        entries = new AVLTree();
        indexer = new IndexAllocator();
    }

    /**
     * Adds a new entry to this level, initial attribute values may be
     * specified.  Default values are used for unspecified attributes.
     *
     * @param initial_values attribute/value pairs
     */
    public void put(ValuePair[] initial_values) {
        Hashtable new_entry = new Hashtable(defaults.length, 1.0f);
        Integer index = indexer.get();
        Object data;
        AVLTree match_tree;
        BitSet matcher;
        int default_count = defaults.length;

        if (initial_values != null) {
            default_count -= initial_values.length;

            // initialise specified attributes
            for (int i = 0; i < initial_values.length; i++) {
                new_entry.put(initial_values[i].key(), initial_values[i].data());
                match_tree = (AVLTree) matching_table.get(initial_values[i].key());
                matcher = (BitSet) match_tree.get(initial_values[i].data());

                if (matcher != null) {
                    matcher.set(index.intValue());
                } else {
                    matcher = new BitSet();
                    matcher.set(index.intValue());
                    match_tree.put(initial_values[i].data(), matcher);
                }
            }
        }

        // initialise unspecified attributes with default values
        for (int i = 0; default_count > 0; i++)
            if (new_entry.get(defaults[i].key()) == null) {
                new_entry.put(defaults[i].key(), defaults[i].data());
                match_tree = (AVLTree) matching_table.get(defaults[i].key());
                matcher = (BitSet) match_tree.get(defaults[i].data());

                if (matcher != null) {
                    matcher.set(index.intValue());
                } else {
                    matcher = new BitSet();
                    matcher.set(index.intValue());
                    match_tree.put(defaults[i].data(), matcher);
                }

                default_count--;
            }

        entries.put(index, new_entry);
        setChanged();
        notifyObservers();
    }

    /**
     * Returns all values of the given attribute.  Each value is paired
     * with a bit pattern identifying entries with that value.
     *
     * @param attribute refers to a particular attribute
     *
     * @return pairs of values and associated entry bit patterns
     */
    public ValuePair[] get(Integer attribute) {
        return (((AVLTree) matching_table.get(attribute)).elements());
    }

    /**
     * Returns a bit pattern identifying entries matching the specified
     * attribute/value pattern.
     *
     * @param values a pattern of attribute/value pairs
     *
     * @return entry bit pattern, or null if there are no matching entries
     */
    public BitSet get(ValuePair[] values) {
        AVLTree match_tree = (AVLTree) matching_table.get(values[0].key());
        BitSet matcher;
        BitSet matched = null;
        BitSet empty_set = new BitSet();

        if (match_tree != null) {
            matcher = (BitSet) match_tree.get(values[0].data());
            matched = (matcher != null) ? (BitSet) matcher.clone() : null;

            for (int i = 1; ((matched != null) && (i < values.length)); i++) {
                match_tree = (AVLTree) matching_table.get(values[i].key());
                matcher = (BitSet) match_tree.get(values[i].data());

                if (matcher == null) {
                    matched = null;
                } else {
                    matched.and(matcher);

                    if (matched.equals(empty_set)) {
                        matched = null;
                    }
                }
            }
        }

        return (matched);
    }

    /**
     * Returns a bit pattern identifying all entries on this level.
     *
     * @return entry bit pattern, or null if the level is empty
     */
    public BitSet getAll() {
        BitSet empty_set = new BitSet();
        BitSet entry_set = indexer.indexes();

        if (entry_set.equals(empty_set)) {
            return (null);
        } else {
            return (entry_set);
        }
    }

    /**
     * Removes the entry identified by the specified index from this
     * level.
     *
     * @param index entry identifier
     */
    public void remove(Integer index) {
        Hashtable entry = (Hashtable) entries.remove(index);
        AVLTree match_tree;
        BitSet matcher;
        BitSet empty_set = new BitSet();

        if (entry != null) {
            for (int i = 0; i < defaults.length; i++) {
                match_tree = (AVLTree) matching_table.get(defaults[i].key());
                matcher = (BitSet) match_tree.get(entry.get(defaults[i].key()));
                matcher.clear(index.intValue());

                if (matcher.equals(empty_set)) {
                    match_tree.remove(entry.get(defaults[i].key()));
                }
            }

            indexer.recycle(index);
            setChanged();
            notifyObservers();
        }
    }

    /**
     * Removes all entries from this level.
     */
    public void clear() {
        for (int i = 0; i < defaults.length; i++)
            ((AVLTree) matching_table.get(defaults[i].key())).clear();

        entries.clear();
        indexer.reset();
    }

    /**
     * The entry identified by the specified index is modified to
     * conform to the given set of attribute/value pairs.
     *
     * @param index entry identifier
     * @param modifications attribute/value pairs
     */
    public void modify(Integer index, ValuePair[] modifications) {
        Hashtable entry = (Hashtable) entries.get(index);
        AVLTree match_tree;
        Object old_data;
        Object new_data;
        BitSet matcher;
        BitSet empty_set = new BitSet();

        if (entry != null) {
            for (int i = 0; i < modifications.length; i++) {
                match_tree = (AVLTree) matching_table.get(modifications[i].key());
                old_data = entry.get(modifications[i].key());
                new_data = modifications[i].data();

                if (!new_data.equals(old_data)) {
                    // remove old value reference from matching table
                    matcher = (BitSet) match_tree.get(old_data);
                    matcher.clear(index.intValue());

                    if (matcher.equals(empty_set)) {
                        match_tree.remove(old_data);
                    }

                    // add reference for new value
                    matcher = (BitSet) match_tree.get(new_data);

                    if (matcher != null) {
                        matcher.set(index.intValue());
                    } else {
                        matcher = new BitSet();
                        matcher.set(index.intValue());
                        match_tree.put(new_data, matcher);
                    }

                    entry.put(modifications[i].key(), new_data);
                    setChanged();
                }
            }

            notifyObservers();
        }
    }

    /**
     * Returns a String representation of an instance of this class.
     *
     * @return DOCUMENT ME!
     */
    public String toString() {
        StringBuffer buffer = new StringBuffer();
        buffer.append("{defaults=[");
        buffer.append(defaults[0].toString());

        for (int i = 1; i < defaults.length; i++) {
            buffer.append(", ");
            buffer.append(defaults[i].toString());
        }

        buffer.append("],\nentries=");
        buffer.append(entries.toString());
        buffer.append("matching table=");
        buffer.append(matching_table.toString());
        buffer.append(", index allocator=");
        buffer.append(indexer.toString());
        buffer.append("}");

        return (buffer.toString());
    }
}
