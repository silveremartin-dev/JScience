package org.jscience.computing.kmeans;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.Iterator;
import java.util.Vector;

/**
 * Generates clusters from a dataset using the K-Means algorithm.
 * <p/>
 * Also contains the main method for running system in test mode.
 *
 * @author Harlan Crystal <hpc4@cornell.edu>
 * @version $Id: KMeans.java,v 1.2 2007-10-21 21:08:01 virtualcall Exp $
 * @date April 20, 2003
 */
public class KMeans {
    /**
     * The maximum number of iterations algorithm may run
     */
    private static final int MAXITER = 10000;

    /**
     * The number of clusters we assume exist in the data
     */
    private int numClusters;

    /**
     * The dataset we are clustering.
     */
    private DataSet dataset;

    /**
     * The array of means
     */
    private Coordinate[] means;

    /**
     * The clusters associated with these means.
     */
    private ClusterSet clusters;

    /**
     * The number of iterations needed to find these clusters.
     */
    private int iterations;

    /**
     * Constructor.
     *
     * @param dataset    The dataset to cluster.
     * @param numCluster The number of clusters to assume exist.
     */
    public KMeans(DataSet dataset, int numClusters) {
        if (numClusters > dataset.numSamples())
            throw new IllegalArgumentException();

        this.dataset = dataset;
        this.numClusters = numClusters;

        findClusters();
    }

    /**
     * Helper function to find the closest mean to a given sample.
     *
     * @param sample The sample to compare the means to.
     * @return The index of the closest mean.
     */
    private int findClosestMean(Coordinate sample) {
        int closestindex = 0;
        double closestval = sample.distance(means[0]);
        for (int i = 1; i < means.length; i++) {
            double dist = sample.distance(means[i]);
            if (closestval > dist) {
                closestindex = i;
                closestval = dist;
            }
        }
        return closestindex;
    }

    /**
     * Helper to update the values of the last seen means
     * <p/>
     * If clusters are uninitialized, creates means by choosing randomly
     * selected samples
     */
    private void updateMeans() {
        if (clusters == null) {
            // initialize means to randomly selected locations
            // TODO: is this suspect? we're using those samples again
            // in next iteration

            this.means = new Coordinate[numClusters];
            Iterator it = dataset.randomIterator();
            for (int i = 0; i < numClusters; i++)
                means[i] = (Coordinate) it.next();
        } else {
            for (int i = 0; i < numClusters; i++)
                means[i] = clusters.get(i).average();
        }
    }

    /**
     * Finds the clusters of given dataset.
     * Iterates until we get convergence, or hit maximum number of iterations.
     */
    private void findClusters() {
        iterations = 0;
        while (iterations < MAXITER && !haveConverged()) {
            updateMeans();
            oneIteration();
            iterations++;
        }
    }

    /**
     * Helper function that checks if the means have stopped changing.
     *
     * @return True if we have converged. False otherwise.
     */
    private boolean haveConverged() {
        if (clusters == null || means == null)
            return false;

        for (int i = 0; i < numClusters; i++) {
            if (!means[i].equals(clusters.get(i).average()))
                return false;

        }
        return true;
    }

    /**
     * Does one iteration of kmeans algorithm.
     * <p/>
     * Updates the clusters values.
     * Updates the means values.
     */
    private void oneIteration() {
        Vector[] unAveragedClusters = new Vector[numClusters];
        for (int i = 0; i < numClusters; i++)
            unAveragedClusters[i] = new Vector();

        for (Iterator it = dataset.iterator(); it.hasNext();) {
            Coordinate data = (Coordinate) it.next();
            int selectedindex = findClosestMean(data);
            unAveragedClusters[selectedindex].add(data);
        }
        // convert collections of samples to clusters with averages.
        clusters = new ClusterSet(numClusters);
        for (int i = 0; i < numClusters; i++)
            clusters.set(i, new Cluster(unAveragedClusters[i]));

    }

    /**
     * Access the number of iterations that were needed to converge to
     * these clusters.
     *
     * @return The number of iterations.
     */
    public int getNumIterations() {
        return iterations;
    }

    /**
     * @return The clusters generated by the algorithm.
     */
    public ClusterSet clusters() {
        return clusters;
    }

    /**
     * A main method for using this in test mode.
     */
    public static void main(String[] args) {
        try {
            if (args.length != 2)
                throw new Exception("Incorrect number of arguments.");

            DataSet fullset = new DataSet(args[0]);
            int maxclusters = Integer.parseInt(args[1]);

            String stars = "*****************************";

            int bestNumClusters = 1;
            double minDescLen = -1;

            for (int numclust = 1; numclust <= maxclusters; numclust++) {
                System.out.println(stars);
                System.out.println("Trying " + numclust + " clusters..");
                KMeans kmeans = new KMeans(fullset, numclust);
                System.out.println("Converged after " +
                        kmeans.getNumIterations() + " iterations");
                ClusterSet clusters = kmeans.clusters();
                int i = 1;
                for (Iterator it = clusters.iterator(); it.hasNext();) {
                    Cluster clust = (Cluster) it.next();
                    System.out.println();
                    System.out.println("Gaussian no. " + i);
                    System.out.println("--------------------");
                    System.out.println("mean " + clust.average());
                    System.out.print("sigma ");
                    for (int j = 0; j < clust.dimension(); j++)
                        System.out.print(clust.standardDeviation(j) + " ");
                    System.out.println();
                    System.out.println("prior " + clusters.prior(i - 1));
                    i++;
                }
                System.out.println();
                System.out.println("Model quality:");
                System.out.println("Log-Likelihood " +
                        clusters.logLikelihood(fullset));
                double desclen = clusters.descriptionLength(fullset);
                if (minDescLen == -1 || desclen < minDescLen) {
                    bestNumClusters = numclust;
                    minDescLen = desclen;
                }
                System.out.println("MDL " + desclen);

            }
            System.out.println(stars);
            System.out.println("The most likely model is " + bestNumClusters +
                    " Gaussians");
        } catch (FileNotFoundException e) {
            System.out.println("Specified file not found.");
            printUsage();
            System.exit(-1);
        } catch (IOException e) {
            System.out.println(e.getMessage());
            printUsage();
            System.exit(-1);
        } catch (Exception e) {
            System.out.println(e.getMessage());
            e.printStackTrace();
            printUsage();
            System.exit(-1);
        }
    }

    /**
     * Describes the usage of this program.
     */
    public static void printUsage() {
        System.out.println("KMeans [filename] [maxclusters]");
        System.out.println("[filename] - The name of a datafile.");
        System.out.println("[maxclusters] - The maximum number of clusters " +
                "to consider.");
    }
}
