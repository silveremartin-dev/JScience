/**
 * JEP - Java Expression Parser JEP is a Java package for parsing and
 * evaluating mathematical expressions. It currently supports user defined
 * variables, constant, and functions. A number of common mathematical
 * functions and constants are included. Author: Nathan Funk Copyright (C)
 * 2000 Nathan Funk JEP is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or (at your
 * option) any later version. JEP is distributed in the hope that it will be
 * useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
 * Public License for more details. You should have received a copy of the GNU
 * General Public License along with JEP; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.jscience.ml.sbml.jep;

/**
 * DOCUMENT ME!
 *
 * @author $author$
 * @version $Revision: 1.3 $
 */
public class SimpleNode implements Node {
    /** DOCUMENT ME! */
    protected Node[] children;

    /** DOCUMENT ME! */
    protected int id;

    /** DOCUMENT ME! */
    protected Node parent;

    /** DOCUMENT ME! */
    protected Parser parser;

/**
     * Creates a new SimpleNode object.
     *
     * @param i DOCUMENT ME!
     */
    public SimpleNode(int i) {
        id = i;
    }

/**
     * Creates a new SimpleNode object.
     *
     * @param p DOCUMENT ME!
     * @param i DOCUMENT ME!
     */
    public SimpleNode(Parser p, int i) {
        this(i);
        parser = p;
    }

    /**
     * Accept the visitor.
     *
     * @param visitor DOCUMENT ME!
     * @param data DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Object childrenAccept(ParserVisitor visitor, Object data) {
        if (children != null) {
            for (int i = 0; i < children.length; ++i)
                children[i].jjtAccept(visitor, data);
        }

        return data;
    }

    /**
     * Accept the visitor in Reverse.
     *
     * @param visitor DOCUMENT ME!
     * @param data DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Object childrenAcceptReverse(ParserVisitor visitor, Object data) {
        if (children != null) {
            for (int i = children.length - 1; i > -1; --i)
                children[i].jjtAccept(visitor, data);
        }

        return data;
    }

    /* Override this method if you want to customize how the node dumps
       out its children. */
    public void dump(String prefix) {
        System.out.println(toString(prefix));

        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode) children[i];

                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * Returns the id of the node (for simpler identification).
     *
     * @return DOCUMENT ME!
     */
    public int getId() {
        return id;
    }

    /**
     * Accept the visitor.
     *
     * @param visitor DOCUMENT ME!
     * @param data DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Object jjtAccept(ParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    /**
     * DOCUMENT ME!
     *
     * @param n DOCUMENT ME!
     * @param i DOCUMENT ME!
     */
    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node[] c = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }

        children[i] = n;
    }

    /**
     * DOCUMENT ME!
     */
    public void jjtClose() {
    }

    /**
     * DOCUMENT ME!
     *
     * @param i DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Node jjtGetChild(int i) {
        return children[i];
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Node jjtGetParent() {
        return parent;
    }

    /**
     * DOCUMENT ME!
     */
    public void jjtOpen() {
    }

    /**
     * DOCUMENT ME!
     *
     * @param n DOCUMENT ME!
     */
    public void jjtSetParent(Node n) {
        parent = n;
    }

    /* You can override these two methods in subclasses of SimpleNode to
       customize the way the node appears when the tree is dumped.  If
       your output uses more than one line you should override
       toString(String), otherwise overriding toString() is probably all
       you need to do. */
    public String toString() {
        return ParserTreeConstants.jjtNodeName[id];
    }

    /**
     * DOCUMENT ME!
     *
     * @param prefix DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public String toString(String prefix) {
        return prefix + toString();
    }
}
