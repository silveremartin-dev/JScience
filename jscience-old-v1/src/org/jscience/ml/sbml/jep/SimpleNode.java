/*
 * JScience - Java(TM) Tools and Libraries for the Advancement of Sciences.
 * Copyright (C) 2025-2026 - Silvere Martin-Michiellot and Gemini AI (Google DeepMind)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/* Generated By:JJTree: Do not edit this line. SimpleNode.java */
package org.jscience.ml.sbml.jep;

/**
 * DOCUMENT ME!
 *
 * @author $author$
 * @version $Revision: 1.3 $
 */
public class SimpleNode implements Node {
    /** DOCUMENT ME! */
    protected Node[] children;

    /** DOCUMENT ME! */
    protected int id;

    /** DOCUMENT ME! */
    protected Node parent;

    /** DOCUMENT ME! */
    protected Parser parser;

/**
     * Creates a new SimpleNode object.
     *
     * @param i DOCUMENT ME!
     */
    public SimpleNode(int i) {
        id = i;
    }

/**
     * Creates a new SimpleNode object.
     *
     * @param p DOCUMENT ME!
     * @param i DOCUMENT ME!
     */
    public SimpleNode(Parser p, int i) {
        this(i);
        parser = p;
    }

    /**
     * Accept the visitor.
     *
     * @param visitor DOCUMENT ME!
     * @param data DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Object childrenAccept(ParserVisitor visitor, Object data) {
        if (children != null) {
            for (int i = 0; i < children.length; ++i)
                children[i].jjtAccept(visitor, data);
        }

        return data;
    }

    /**
     * Accept the visitor in Reverse.
     *
     * @param visitor DOCUMENT ME!
     * @param data DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Object childrenAcceptReverse(ParserVisitor visitor, Object data) {
        if (children != null) {
            for (int i = children.length - 1; i > -1; --i)
                children[i].jjtAccept(visitor, data);
        }

        return data;
    }

    /* Override this method if you want to customize how the node dumps
       out its children. */
    public void dump(String prefix) {
        System.out.println(toString(prefix));

        if (children != null) {
            for (int i = 0; i < children.length; ++i) {
                SimpleNode n = (SimpleNode) children[i];

                if (n != null) {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * Returns the id of the node (for simpler identification).
     *
     * @return DOCUMENT ME!
     */
    public int getId() {
        return id;
    }

    /**
     * Accept the visitor.
     *
     * @param visitor DOCUMENT ME!
     * @param data DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Object jjtAccept(ParserVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }

    /**
     * DOCUMENT ME!
     *
     * @param n DOCUMENT ME!
     * @param i DOCUMENT ME!
     */
    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        } else if (i >= children.length) {
            Node[] c = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }

        children[i] = n;
    }

    /**
     * DOCUMENT ME!
     */
    public void jjtClose() {
    }

    /**
     * DOCUMENT ME!
     *
     * @param i DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Node jjtGetChild(int i) {
        return children[i];
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }

    /**
     * DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public Node jjtGetParent() {
        return parent;
    }

    /**
     * DOCUMENT ME!
     */
    public void jjtOpen() {
    }

    /**
     * DOCUMENT ME!
     *
     * @param n DOCUMENT ME!
     */
    public void jjtSetParent(Node n) {
        parent = n;
    }

    /* You can override these two methods in subclasses of SimpleNode to
       customize the way the node appears when the tree is dumped.  If
       your output uses more than one line you should override
       toString(String), otherwise overriding toString() is probably all
       you need to do. */
    public String toString() {
        return ParserTreeConstants.jjtNodeName[id];
    }

    /**
     * DOCUMENT ME!
     *
     * @param prefix DOCUMENT ME!
     *
     * @return DOCUMENT ME!
     */
    public String toString(String prefix) {
        return prefix + toString();
    }
}
