/*+
 * $Id: AstronomicalCoordinates.java,v 1.3 2007-11-20 18:55:46 virtualcall Exp $
 *
 * $Log: not supported by cvs2svn $
 * Revision 1.2  2007/11/13 22:35:06  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 *
 * Revision 1.1  2007/11/05 22:59:41  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 *
 * Revision 1.2  2007/10/21 17:43:15  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 *
 * Revision 1.1  2006/09/07 21:14:31  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.3  2006/08/13 17:14:00  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.2  2006/07/29 22:14:53  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.1  2006/07/28 22:37:56  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.4  2006/07/12 20:35:30  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.3  2006/07/09 21:13:24  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.2  2006/07/07 22:32:56  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.1  2006/07/05 21:04:53  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.1  2006/07/04 21:47:40  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.2  2006/07/02 20:16:34  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 1.1  2006/06/27 21:35:37  virtualcall
 * Issue number:
 * Obtained from:
 * Submitted by:
 * Reviewed by:
 * CVS: ----------------------------------------------------------------------
 * CVS: Issue number:
 * CVS:   If this change addresses one or more issues,
 * CVS:   then enter the issue number(s) here.
 * CVS: Obtained from:
 * CVS:   If this change has been taken from another system,
 * CVS:   then name the system in this line, otherwise delete it.
 * CVS: Submitted by:
 * CVS:   If this code has been contributed to the project by someone else; i.e.,
 * CVS:   they sent us a patch or a set of diffs, then include their name/email
 * CVS:   address here. If this is your work then delete this line.
 * CVS: Reviewed by:
 * CVS:   If we are doing pre-commit code reviews and someone else has
 * CVS:   reviewed your changes, include their name(s) here.
 * CVS:   If you have not had it reviewed then delete this line.
 *
 * Revision 4.1  2004/08/09 07:53:06  hme
 * Version 2.1.1.
 *
 * Revision 3.1  2004/07/28 10:47:43  hme
 * Version 2.1.
 *
 * Revision 2.5  2003/09/17 16:01:57  hme
 * Add GetTopo() method.
 *
 * Revision 2.4  2003/09/16 18:47:03  hme
 * *** empty log message ***
 *
 * Revision 2.3  2003/09/16 17:40:32  hme
 * Package review.
 *
 * Revision 2.2  2003/09/15 17:10:15  hme
 * Changed Station method name GetX0Z.
 *
 * Revision 2.1  2003/09/14 09:49:27  hme
 * *** empty log message ***
 *
 * Revision 1.14  2003/06/14 15:21:56  hme
 * Add getHorizontal() public method.
 *
 * Revision 1.13  2003/03/09 19:22:03  hme
 * *** empty log message ***
 *
 * Revision 1.12  2002/07/16 11:39:41  hme
 * Make the Set*() methods protected.  Most subclasses should not permit
 * the use of these by their user.  E.g. the Sun (subsubclass of this will
 * never be at the position the user might set with these.  The NamedObject
 * class could have a subclass FixedObject that could make these methods
 * public, but for now there is no need, because user commands to set
 * coordinates are dealt with by the NamedObject class which can use these
 * protected methods without problem.
 *
 * Revision 1.11  2002/07/13 13:46:23  hme
 * Consolidating documentation.
 *
 * Revision 1.9  2002/06/22 10:15:34  hme
 * Fix Hori2Topo.
 *
 * Revision 1.8  2002/06/22 10:01:41  hme
 * Add SetEcl(), setTopocentric(), SetHori().
 *
 * Revision 1.6  2002/06/20 08:24:29  hme
 * Set*() methods for all systems within the domain of this class.
 *
 * Revision 1.4  2002/06/16 11:09:35  hme
 * Obliquity() and conversions between RA/Dec and ecliptic.
 *
 * Revision 1.3  2002/06/16 10:27:41  hme
 * B1950/J2000 conversion should now be complete, including FK4/FK5 equinox
 * correction.
 *
 * Revision 1.2  2002/06/16 09:34:08  hme
 * Coordinate transforms Gal-B1950-J2000-Mean should work now.  The
 * B1950/J2000 transform uses FK4 precession, but does not yet take care of
 * the equinox correction necessary for FK4/FK5 transition.
 *
 * Revision 1.1  2002/06/15 19:47:27  hme
 * Initial revision
 *
 *-*/

package org.jscience.astronomy.solarsystem;

import org.jscience.astronomy.MiscellaneousUtils;
import org.jscience.util.Positioned;


/**
 * <p>The <code>AstronomyCoordinates</code> class is for storage of an array of positions in
 * space, such as those of satellites, planets or stars.  The position stored
 * is rectangular, and the unit is Gm.  Typical heights above sea level are
 * then 10<sup>-9</sup>, while c/H, the speed of light divided by the Hubble
 * constant, is 10<sup>26</sup>.  The radius of a proton would be on the
 * order of 10<sup>-24</sup>.  So this is a sensible unit to describe
 * anything in the Universe.  All these numbers are within the range of a
 * double precision number, most probably even their fourth powers are.
 * <p/>
 * <p>The epoch (state of proper motion for stars, time for which the ephemeris
 * of a comet etc is caltulated, etc.) is unspecified.  The positions refer
 * to the mean equinox of J2000.0.  Hence the state of precession is known
 * and the state of nutation ignored.  Positions beyond the Solar System are
 * heliocentric, i.e. parallax and annual aberration are not applied.
 * Positions within the Solar System are mean geocentric astrometric,
 * i.e. the light travel time from the planet to the Earth has been corrected
 * for, but annual aberration is not applied.
 * <p/>
 * <p>The positions can be stored and retrieved in a variety of coordinate
 * systems other than J2000, which is used internally.  But in all cases we
 * deal with mean rather than true and astrometric positions rather than
 * true, apparent or observed positions.  The coordinate systems we deal with
 * form a logical sequence of four with three branches.  Arguably you could
 * re-arange this into a sequence of six with one branch:
 * <p/>
 * <pre>
 * B1950 ------ J2000 ------ mean ------ topo.
 * |                        |           |
 * |                        |           |
 * gal.                     ecl.        hori.
 * </pre>
 * <p/>
 * <dl>
 * <dt>J2000
 * <dd>Heliocentric mean or geocentric astrometric position for equinox
 * J2000.0.  This is the internal representation.  The spherical coordinates
 * in this system are right ascension (RA) and declination (Dec).
 * <dt>B1950
 * <dd>Heliocentric mean or geocentric astrometric position for equinox
 * B1950 (J1949.99979).  This is the standard equinox in common use for
 * much of the 20th century.  The coordinates differ from J2000 due
 * to precession, but also due to a change in the reference system (FK4
 * instead of FK5).  The spherical coordinates
 * in this system are right ascension (RA) and declination (Dec).
 * <dt>Mean equinox of date
 * <dd>Heliocentric mean or geocentric astrometric position for equinox
 * of date.  This differs from J2000 due to precession.  This is often the
 * natural system to use, in particular in the Solar System and in conversion
 * to topocentric or horizontal coordinates.  The spherical coordinates
 * in this system are right ascension (RA) and declination (Dec).
 * <dt>Topocentric
 * <dd>Topocentric astrometric position for equinox of date.  Since we ignore
 * annual parallaxes, positions outside the Solar System are here not
 * strictly topocentric, just like in J2000 above they are not strictly
 * geocentric.  Topocentric coordinates differ from "mean equinox of date"
 * coordinates due to diurnal parallax, i.e. the offset of the observatory
 * from the centre of the Earth.  Another difference is that local sidereal
 * time is taken into account.  The spherical coordinates
 * in this system are hour angle (HA) and declination (Dec).
 * <dt>Galactic l<sup>II</sup>,b<sup>II</sup>
 * <dd>Galactic coordinates as defined after radio observations in the middle
 * of the 20th century indicated the location of the galactic centre.  The
 * transform from and to B1950 defines this system.  The spherical
 * coordinates in this system are longitude along the galactic plane counting
 * from the galactic centre (l) and latitude above the galactic plane (b).
 * <dt>Ecliptic
 * <dd>Mean ecliptic coordinates.  These depend on the mean obliquity at the
 * time and are longitude along the ecliptic from the mean equinox of date
 * and latitude above the ecliptic.
 * <dt>Horizontal
 * <dd>Mean topocentric position in azimuth along the horizon counting from
 * North through East and elevation above the mathematical horizon.
 * Refraction is not taken into account.
 * </dl>
 * <p/>
 * <p>An overview of terms used in stellar and planetary coordinates seems
 * useful here.  For stars:
 * <p/>
 * <ul>
 * <li>The <em>absolute position</em> is from a fundamental catalogue.  Such
 * catalogues contain only thousands of stars for which many careful
 * measurements have been carried out.
 * <li>A <em>relative position</em> is from larger and less precise catalogues.
 * <li>An <em>approximate position</em> is from even larger and even less
 * precise catalogues.
 * <li>The first set of corrections to make to get from catalogue positions to
 * what one observes at a particular station at a particular time, is for
 * proper motion and secular aberration, due to the stars in the Galaxy
 * moving with different spatial velocities.
 * <ul>
 * <li>Correction for <em>proper motion</em> itself just takes account of the
 * fact that at different times the position of the star is different.
 * Catalogue positions are valid for a certain <em>epoch</em>.  Reduction to
 * different epochs is by linear extrapolation of right ascension and
 * declination.
 * </ul>
 * <li>The next effect to take account of is <em>precession</em>.  Precession
 * is due (in increasing order of importance) to the long-term changes in (i)
 * the orientation of the ecliptic in the galactic environment, (ii) the
 * inclination of the equator against the ecliptic, (iii) the position of the
 * equatorial pole on the sky.  Catalogues list positions for a certain
 * <em>equinox</em> or <em>equinox and ecliptic</em>.  This is in fact a
 * time, meaning they use the mean orientation of ecliptic and equator as
 * they were or will be at that time.
 * <li>The <em>mean position</em> is after reduction for precession to the mean
 * equinox and ecliptic of your choice.  More to the point this is before
 * reduction for nutation.
 * <li><em>Nutation</em> is due to a shorter-term variation of the orientation
 * of ecliptic and equator.  The effect is not exactly small, but unlike
 * precession it does not accumulate over hundreds or thousands of years.
 * <li>The <em>true position</em> is after reduction for nutation to the
 * true equinox and ecliptic of your choice.
 * <li>Next is a triplet of reductions from heliocentric to geocentric.
 * <ul>
 * <li>The largest effect here is <em>annual aberration</em>.  Due to the
 * Earth's heliocentric velocity star's positions are shifted slightly
 * towards the forward direction of this motion.  This effect is strongest
 * at about 20 arc seconds (v/c rad) at the ecliptical longitude of the Sun
 * and at its opposite longitude.
 * <li>The <em>apparent position</em> is after correction for annual
 * aberration.
 * <li><em>Light deflection</em> due to the Sun's gravitation amounts to 2 arc
 * seconds near the limb of the Sun.
 * <li>The <em>annual parallax</em> is the small shift in position that a star
 * suffers due to the Earth being on different sides of the Sun at different
 * times of the year.
 * </ul>
 * <li>The <em>observed position</em> is after correction for all these
 * effects.  It is a geocentric position.
 * <li>Reduction to the topocentre involves reduction for <em>diurnal
 * parallax</em> and <em>diurnal aberration</em>, the offset of the
 * observatory from the centre of the Earth and the velocity of the
 * observatory due to the Earth's rotation.
 * <li><em>Polar motion</em> is the change of the Earth's rotation axis with
 * repect to the Earth's surface.  There are two main periodic effects here.
 * One is the seasonal change of the mass distribution near the surface -
 * leaves growing in spring and falling to the ground in autumn.  The other
 * is due to the elasticity of the Earth.  The effect is small at about 0.3
 * arc second.
 * <li><em>Refraction</em> is the effect whereby the Earth's atmosphere acts
 * like a lens and lifts positions to higher elevation.  Near the horizon the
 * effect is not small at about 33 arc minutes for visible light.
 * </ul>
 * <p/>
 * <p>For planets the terminology is a little different.  Planetary ephemeris
 * are often expressed in the <em>mean equinox and ecliptic of date</em>,
 * meaning they use the orientation of ecliptic and equator as it is at the
 * time for which the ephemeris is valid.
 * <p/>
 * <ul>
 * <li>For a planet's <em>geometric position</em> no light time effects have
 * been corrected.  The geocentric position is simply the difference between
 * the heliocentric positions of the planet and the Earth.
 * <li>For an <em>astrometric position</em> light time effects of the
 * heliocentric velocity of the planet have been corrected.  This can be
 * compared to a stellar position that has been reduced for parallax but not
 * for aberration.  Since the stellar parallax is small compared to the
 * aberration, this is comparable to the mean position of a star.
 * <li>For an <em>apparent position</em> light time effects of the geocentric
 * velocity of the planet have been corrected.  This can be compared to the
 * observed position of a star (i.e. one where annual aberration has been
 * applied).
 * </ul>
 * <p/>
 * <p>Sputnik uses mean positions for stars and astrometric positions for
 * planets.  In converting to topocentre, Sputnik ignores nutation, all three
 * annual effects, diurnal aberration and polar motion.  Refraction is taken
 * into account only for calculating rise and set times.
 * <p/>
 * <p>Copyright: &copy; 2002-2003 Horst Meyerdierks.
 * <p/>
 * <p>This programme is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public Licence as
 * published by the Free Software Foundation; either version 2 of
 * the Licence, or (at your option) any later version.
 * <p/>
 * <p>This programme is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public Licence for more details.
 * <p/>
 * <p>You should have received a copy of the GNU General Public Licence
 * along with this programme; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 * <p/>
 * <p>$Id: AstronomicalCoordinates.java,v 1.3 2007-11-20 18:55:46 virtualcall Exp $
 * <p/>
 * <dl>
 * <dt><strong>2.5:</strong> 2003/09/17 hme
 * <dd>Add GetTopo() method.
 * <dt><strong>2.3:</strong> 2003/09/16 hme
 * <dd>Package review.
 * <dt><strong>1.14:</strong> 2003/06/14 hme
 * <dd>Add getHorizontal() public method.
 * <dt><strong>1.13:</strong> 2003/03/09 hme
 * <dd>Review documentation, in particular mathematics.
 * <dt><strong>1.12:</strong> 2002/07/16 hme
 * <dd>Make the Set*() methods protected.  Most subclasses should not permit
 * the use of these by their user.  E.g. the Sun (subsubclass of this will
 * never be at the position the user might set with these.  The NamedObject
 * class could have a subclass FixedObject that could make these methods
 * public, but for now there is no need, because user commands to set
 * coordinates are dealt with by the NamedObject class which can use these
 * protected methods without problem.
 * <dt><strong>1.11:</strong> 2002/07/13 hme
 * <dd>Consolidating documentation.
 * <dt><strong>1.9:</strong> 2002/06/22 hme
 * <dd>Add SetEcl(), setTopocentric(), SetHori().
 * <dt><strong>1.7:</strong> 2002/06/21 hme
 * <dd>Coordinate transforms to HA/Dec and A/h.
 * <dt><strong>1.6:</strong> 2002/06/20 hme
 * <dd>Set*() methods for all systems within the domain of this class.
 * <dt><strong>1.4:</strong> 2002/06/16 hme
 * <dd>Obliquity() and conversions between RA/Dec and ecliptic.
 * <dt><strong>1.3:</strong> 2002/06/16 hme
 * <dd>Coordinate transforms Gal-B1950-J2000-Mean should work now.  The
 * B1950/J2000 transform uses FK4 precession, and takes care of
 * the equinox correction necessary for FK4/FK5 transition.
 * <dt><strong>1.1:</strong> 2002/06/15 hme
 * <dd>Translated from C++ (Sputnik 1.9).
 * </dl>
 *
 * @author Horst Meyerdierks, c/o Royal Observatory,
 *         Blackford Hill, Edinburgh, EH9 3HJ, Scotland;
 *         &lt; hme &#64; roe.ac.uk &gt;
 * @see org.jscience.astronomy.solarsystem
 */

//there is a lot of overlap with TimeUtils
//moreover, there may be different results between these two classes
//hopefully, TimeUtils should always be (much) more precise    
public class AstronomicalCoordinates implements Positioned {

    /**
     * Conversion matrix B1950 to galactic longitude and latitude.
     */

    private static final double B50toLB[] = {
            Math.cos(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    - Math.sin(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            Math.sin(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    + Math.cos(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            Math.sin(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            -Math.cos(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    - Math.sin(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            -Math.sin(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    + Math.cos(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.cos(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            Math.cos(327. / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            Math.sin(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            -Math.cos(282.25 / MiscellaneousUtils.DEGREES_PER_RADIAN)
                    * Math.sin(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN),

            Math.cos(62.6 / MiscellaneousUtils.DEGREES_PER_RADIAN)
    };

    /**
     * Parameter for matrix to convert between B1950 and J2000.
     */
    private static final double zeta = 1152.552 / 3600. / MiscellaneousUtils.DEGREES_PER_RADIAN;

    /**
     * Parameter for matrix to convert between B1950 and J2000.
     */
    private static final double z = 1152.750 / 3600. / MiscellaneousUtils.DEGREES_PER_RADIAN;

    /**
     * Parameter for matrix to convert between B1950 and J2000.
     */
    private static final double theta = 1002.016 / 3600. / MiscellaneousUtils.DEGREES_PER_RADIAN;

    /**
     * Conversion matrix B1950 to J2000.
     */
    private static final double B50toJ00[] = {
            +Math.cos(zeta) * Math.cos(theta) * Math.cos(z)
                    - Math.sin(zeta) * Math.sin(z),
            -Math.sin(zeta) * Math.cos(theta) * Math.cos(z)
                    - Math.cos(zeta) * Math.sin(z),
            -Math.sin(theta) * Math.cos(z),
            +Math.cos(zeta) * Math.cos(theta) * Math.sin(z)
                    + Math.sin(zeta) * Math.cos(z),
            -Math.sin(zeta) * Math.cos(theta) * Math.sin(z)
                    + Math.cos(zeta) * Math.cos(z),
            -Math.sin(theta) * Math.sin(z),
            +Math.cos(zeta) * Math.sin(theta),
            -Math.sin(zeta) * Math.sin(theta),
            +Math.cos(theta)
    };

    private double[] coords;

    public AstronomicalCoordinates() {

        coords = new double[3];
        coords[0] = 0;
        coords[1] = 0;
        coords[2] = 0;

    }

    public AstronomicalCoordinates(double x, double y, double z) {

        coords = new double[3];
        coords[0] = x;
        coords[1] = y;
        coords[2] = z;

    }

    public AstronomicalCoordinates(double[] coords) {

        if (coords.length == 3) {
            this.coords = coords;
        } else throw new IllegalArgumentException("The array of coordinates must be of length 3.");

    }

    public double[] getJ2000() {

        return coords;

    }

    public double[] getPosition() {

        return getJ2000();

    }

    /**
     * Convert B1950 to galactic coordinates.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>The transform uses Euler angles of 282.25&deg;, 327&deg; and
     * 62.6&deg;.  The last of these is the inclination of the galactic plane,
     * as the galactic pole is defined to be at declination 27.4&deg;.  The
     * second angle comes from the distance of 33&deg; between the Galactic
     * Centre and the node of the galactic plane with the equator.  The first
     * angle is 90&deg; larger than the right ascension of the galactic pole.
     * See e.g.
     * Jean Meeus, 1991, <em>Astronomical Algorithms</em>, Willmann-Bell, Richmond VA, p.89f.
     * <p/>
     * <p>The matrix to transform from B1950 to galactic is
     * <p/>
     * <p>M<sub>11</sub> = cos(282.25&deg;) cos(327&deg;)
     * - sin(282.25&deg;) sin(327&deg;) cos(62.6&deg;)
     * <br>M<sub>12</sub> = sin(282.25&deg;) cos(327&deg;)
     * + cos(282.25&deg;) sin(327&deg;) cos(62.6&deg;)
     * <br>M<sub>13</sub> = sin(327&deg;) sin(62.6&deg;)
     * <br>M<sub>21</sub> = -cos(282.25&deg;) sin(327&deg;)
     * - sin(282.25&deg;) cos(327&deg;) cos(62.6&deg;)
     * <br>M<sub>22</sub> = -sin(282.25&deg;) sin(327&deg;)
     * + cos(282.25&deg;) cos(327&deg;) cos(62.6&deg;)
     * <br>M<sub>23</sub> = cos(327&deg;) sin(62.6&deg;)
     * <br>M<sub>31</sub> = sin(282.25&deg;) sin(62.6&deg;)
     * <br>M<sub>32</sub> = -cos(282.25&deg;) sin(62.6&deg;)
     * <br>M<sub>33</sub> = cos(62.6&deg;)
     *
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertB1950ToGalactic(double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        outTriplet[0] = B50toLB[0] * inTriplet[0]
                + B50toLB[1] * inTriplet[1]
                + B50toLB[2] * inTriplet[2];
        outTriplet[1] = B50toLB[3] * inTriplet[0]
                + B50toLB[4] * inTriplet[1]
                + B50toLB[5] * inTriplet[2];
        outTriplet[2] = B50toLB[6] * inTriplet[0]
                + B50toLB[7] * inTriplet[1]
                + B50toLB[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Convert B1950 to J2000 coordinates.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>Jean Meeus, 1991, <em>Astronomical Algorithms</em>, Willmann-Bell, Richmond VA, p.130.
     * illustrates the conversion from FK4 to FK5 and in particular from B1950
     * FK4 to a Julian epoch and FK5.  In that case his start epoch is
     * signified by T&nbsp;=&nbsp;0.5.  We specialise further and fix the end
     * to J2000, hence the epoch difference is t&nbsp;=&nbsp;0.5, also.
     * <p/>
     * <p>T = (B1950.0 - B1900.0) / 100 = 0.5
     * <br>t = (J2000.0 - B1950.0) / 100 = 0.5
     * <p>&zeta; = (2304.250 + 1.396 T) t
     * +     0.302 t<sup>2</sup>
     * +     0.018 t<sup>3</sup>
     * <br>z/" = &zeta;/"
     * +     0.791 t<sup>2</sup>
     * +     0.001 t<sup>3</sup>
     * <br>&theta; = (2004.682 - 0.853 T) t
     * -     0.426 t<sup>2</sup>
     * -     0.042 t<sup>3</sup>
     * <p>&zeta; = 1152.552"
     * <br>z = 1152.750"
     * <br>&theta; = 1002.016"
     * <p/>
     * <p>Jean Meeus, 1991, <em>Astronomical Algorithms</em>, Willmann-Bell, Richmond VA, p.126,
     * does not give the transform matrix.  From
     * USNO/RGO, 1990, <em>The Astronomical Almanach for the Year 1992</em>, U.S. Government Printing Office, Washington DC, Her Majesty's Stationery Office, London, p.B18,
     * we presume that for transfrom from T to T+t it is:
     * <p/>
     * <p>M<sub>11</sub>  =  cos(&zeta;)  * cos(&theta;) * cos(z)
     * - sin(&zeta;) * sin(z)
     * <br>M<sub>12</sub> = -sin(&zeta;)  * cos(&theta;) * cos(z)
     * - cos(&zeta;) * sin(z)
     * <br>M<sub>13</sub> = -sin(&theta;) * cos(z)
     * <br>M<sub>21</sub> =  cos(&zeta;)  * cos(&theta;) * sin(z)
     * + sin(&zeta;) * cos(z)
     * <br>M<sub>22</sub> = -sin(&zeta;)  * cos(&theta;) * sin(z)
     * + cos(&zeta;) * cos(z)
     * <br>M<sub>23</sub> = -sin(&theta;) * sin(z)
     * <br>M<sub>31</sub> =  cos(&zeta;)  * sin(&theta;)
     * <br>M<sub>32</sub> = -sin(&zeta;)  * sin(&theta;)
     * <br>M<sub>33</sub> =  cos(&theta;)
     * <p/>
     * <p>Returning to
     * Jean Meeus, 1991, <em>Astronomical Algorithms</em>, Willmann-Bell, Richmond VA, p.130,
     * dealing with the precession between 1950 and 2000 like this is not
     * sufficient.  We have to add to the right ascension the equinox
     * correction
     * <p/>
     * <p>&Delta;&alpha; = (0.0775 + 0.0850 T) s = 1.8"
     *
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertB1950ToJ2000(double inTriplet[]) {

        final double dRA = 1.8 / 3600. / MiscellaneousUtils.DEGREES_PER_RADIAN;
        double x, y;
        double[] outTriplet;

        outTriplet = new double[3];

        /* Precession. */

        x = B50toJ00[0] * inTriplet[0]
                + B50toJ00[1] * inTriplet[1]
                + B50toJ00[2] * inTriplet[2];
        y = B50toJ00[3] * inTriplet[0]
                + B50toJ00[4] * inTriplet[1]
                + B50toJ00[5] * inTriplet[2];
        outTriplet[2] = B50toJ00[6] * inTriplet[0]
                + B50toJ00[7] * inTriplet[1]
                + B50toJ00[8] * inTriplet[2];

        /* Equinox correction FK4-FK5. */

        outTriplet[0] = x * Math.cos(dRA) - y * Math.sin(dRA);
        outTriplet[1] = x * Math.sin(dRA) + y * Math.cos(dRA);

        return outTriplet;

    }

    /**
     * Convert equinox of date ecliptic coordinates to RA/Dec.
     * <p/>
     * <p>See also {@link #convertMeanToEcliptic convertMeanToEcliptic}.
     */

    public final static double[] convertEclipticToMean(JulianTime aEquinox, double inTriplet[]) {

        double eps;
        double[] outTriplet;

        outTriplet = new double[3];

        eps = obliquity(aEquinox);

        double mat[] = {
                1., 0., 0.,
                0., Math.cos(eps), Math.sin(eps),
                0., -Math.sin(eps), Math.cos(eps)
        };

        outTriplet[0] = mat[0] * inTriplet[0]
                + mat[3] * inTriplet[1]
                + mat[6] * inTriplet[2];
        outTriplet[1] = mat[1] * inTriplet[0]
                + mat[4] * inTriplet[1]
                + mat[7] * inTriplet[2];
        outTriplet[2] = mat[2] * inTriplet[0]
                + mat[5] * inTriplet[1]
                + mat[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Convert galactic to B1950 coordinates.
     * <p/>
     * See also {@link #convertB1950ToGalactic convertB1950ToGalactic}.
     */

    public final static double[] convertGalacticToB1950(double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        outTriplet[0] = B50toLB[0] * inTriplet[0]
                + B50toLB[3] * inTriplet[1]
                + B50toLB[6] * inTriplet[2];
        outTriplet[1] = B50toLB[1] * inTriplet[0]
                + B50toLB[4] * inTriplet[1]
                + B50toLB[7] * inTriplet[2];
        outTriplet[2] = B50toLB[2] * inTriplet[0]
                + B50toLB[5] * inTriplet[1]
                + B50toLB[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Get the horizontal spherical coordinates.
     * <p/>
     * <p>This retrieves the position stored with conversion to horizontal
     * spherical coordinates (azimuth and elevation).
     *
     * @param aStation The time and location of the observatory.  The station clock is also
     *                 the date of the equinox.
     * @return Three floating point numbers containing the azimuth in radian (North is
     *         zero, East 90&deg;, etc.), the elevation in radian and the
     *         topocentric distance in Gm.
     */
    public final static double[] getHorizontal(EarthStation aStation, JulianTime time, double aTriplet[]) {

        double[] result;

        result = convertJ2000ToMean(time, aTriplet);
        result = convertMeanToTopocentric(aStation, time, result);
        result = convertTopocentricToHorizontal(aStation, result);
        result = MiscellaneousUtils.convertOrthogonalToSpherical(result);
        result[0] = MiscellaneousUtils.normalizeAngleAt180(result[0]);

        return result;

    }

    /**
     * Get the topocentric spherical coordinates.
     * <p/>
     * <p>This retrieves the position stored with conversion to topocentric
     * spherical coordiaates (hour angle and declination).
     *
     * @param aStation The time and location of the observatory.  The station clock is also
     *                 the date of the equinox.
     * @return Three floating point numbers containing the hour angle in radian
     *         (South is zero, West 6&nbsp;h, etc.), the declination in radian and the
     *         topocentric distance in Gm.
     */
    public final static double[] getTopocentric(EarthStation aStation, JulianTime time, double aTriplet[]) {

        double[] result;

        result = convertJ2000ToMean(time, aTriplet);
        result = convertMeanToTopocentric(aStation, time, aTriplet);
        MiscellaneousUtils.convertOrthogonalToSpherical(result);
        result[0] = MiscellaneousUtils.normalizeAngleAt180(result[0]);

        return result;

    }

    /**
     * Convert azimuth and elevation to HA/Dec.
     * <p/>
     * <p/>
     * <p>The transform is
     * <p/>
     * <p><table>
     * <tr align="center">
     * <td>(<br>(<br>(</td>
     * <td>x'<br>y'<br>z'</td>
     * <td>)<br>)<br>)</td>
     * <td>=</td>
     * <td>(<br>(<br>(</td>
     * <td>-sin(&phi;)<br>0<br>cos(&phi;)</td>
     * <td>0<br>-1<br>0</td>
     * <td>cos(&phi;)<br>0<br>sin(&phi;)</td>
     * <td>)<br>)<br>)</td>
     * <td>(<br>(<br>(</td>
     * <td>x"<br>y"<br>z"</td>
     * <td>)<br>)<br>)</td>
     * </tr>
     * </table>
     * <p/>
     * <p>The matrix here includes an inversion of the x and y axes, which
     * amounts to a rotation by 180 degrees about the z axis.  This takes account
     * of the fact that azimuth counts from North while hour angle counts from
     * South.  Both count retrograde (clockwise).
     *
     * @param aStation  The location of the observatory.
     * @param inTriplet Array of 3 given numbers, forming an xyz
     *                  position in Gm.
     * @return Array of 3 numbers, forming an xyz
     *         position in Gm.
     */
    public final static double[] convertHorizontalToTopocentric(EarthStation aStation, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double mat[] = new double[4];
        double theLat;

        theLat = aStation.getLatitude();

        mat[0] = -Math.sin(theLat);
        mat[1] = Math.cos(theLat);
        mat[2] = Math.cos(theLat);
        mat[3] = Math.sin(theLat);

        outTriplet[0] = inTriplet[0] * mat[0]
                + inTriplet[2] * mat[1];
        outTriplet[1] = -inTriplet[1];
        outTriplet[2] = inTriplet[0] * mat[2]
                + inTriplet[2] * mat[3];

        return outTriplet;

    }

    /**
     * Convert J2000 to B1950 coordinates.
     * <p/>
     * See also {@link #convertB1950ToJ2000 B19502J2000}.
     */

    public final static double[] convertJ2000ToB1950(double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        final double dRA = 1.8 / 3600. / MiscellaneousUtils.DEGREES_PER_RADIAN;
        double x, y;

        /* Equinox correction FK4-FK5. */

        x = inTriplet[0] * Math.cos(dRA)
                + inTriplet[1] * Math.sin(dRA);
        y = inTriplet[1] * Math.cos(dRA)
                - inTriplet[0] * Math.sin(dRA);

        /* Precession. */

        outTriplet[0] = B50toJ00[0] * x
                + B50toJ00[3] * y
                + B50toJ00[6] * inTriplet[2];
        outTriplet[1] = B50toJ00[1] * x
                + B50toJ00[4] * y
                + B50toJ00[7] * inTriplet[2];
        outTriplet[2] = B50toJ00[2] * x
                + B50toJ00[5] * y
                + B50toJ00[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Convert J2000 to equinox of date coordinates.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>The transform uses a matrix calculated from
     * USNO/RGO, 1990, <em>The Astronomical Almanach for the Year 1992</em>, U.S. Government Printing Office, Washington DC, Her Majesty's Stationery Office, London, p.B18.
     * <p/>
     * <p>t = (Ep - J2000.0) / 100
     * <p>&zeta;/&deg;
     * = 0.6406161 t + 8.39 10<sup>-5</sup> t<sup>2</sup>
     * + 5 10<sup>-6</sup> t<sup>3</sup>
     * <br>z/&deg; = 0.6406161 t + 3.041 10<sup>-4</sup> t<sup>2</sup>
     * + 5.1 10<sup>-6</sup> t<sup>3</sup>
     * <br>&theta;/&deg;
     * = 0.556753 t - 1.185 10<sup>-4</sup> t<sup>2</sup>
     * - 1.16 10<sup>-5</sup> t<sup>3</sup>
     * <p>M<sub>11</sub> = cos(&zeta;) * cos(&theta;) * cos(z)
     * - sin(&zeta;) * sin(z)
     * <br>M<sub>12</sub> = -sin(&zeta;) * cos(&theta;) * cos(z)
     * - cos(&zeta;) * sin(z)
     * <br>M<sub>13</sub> = -sin(&theta;) * cos(z)
     * <br>M<sub>21</sub> = cos(&zeta;) * cos(&theta;) * sin(z)
     * + sin(&zeta;) * cos(z)
     * <br>M<sub>22</sub> = -sin(&zeta;) * cos(&theta;) * sin(z)
     * + cos(&zeta;) * cos(z)
     * <br>M<sub>23</sub> = -sin(&theta;) * sin(z)
     * <br>M<sub>31</sub> = cos(&zeta;) * sin(&theta;)
     * <br>M<sub>32</sub> = -sin(&zeta;) * sin(&theta;)
     * <br>M<sub>33</sub> = cos(&theta;)
     * <p/>
     * <p>This matrix transforms from J2000 to Ep.  The inverse transform is
     * achieved with the transposed matrix.
     *
     * @param aEquinox  The equinox to which the returned coordinates should refer.
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertJ2000ToMean(JulianTime aEquinox, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double t, zeta, z, theta;

        t = (aEquinox.getJulianEpoch() - 2000.) / 100.;
        zeta = .6406161 * t + 8.39e-5 * t * t
                + 5e-6 * t * t * t;
        z = .6406161 * t + 3.041e-4 * t * t
                + 5.1e-6 * t * t * t;
        theta = .556753 * t - 1.185e-4 * t * t
                - 1.16e-5 * t * t * t;
        zeta /= MiscellaneousUtils.DEGREES_PER_RADIAN;
        z /= MiscellaneousUtils.DEGREES_PER_RADIAN;
        theta /= MiscellaneousUtils.DEGREES_PER_RADIAN;

        double mat[] = {
                +Math.cos(zeta) * Math.cos(theta) * Math.cos(z)
                        - Math.sin(zeta) * Math.sin(z),
                -Math.sin(zeta) * Math.cos(theta) * Math.cos(z)
                        - Math.cos(zeta) * Math.sin(z),
                -Math.sin(theta) * Math.cos(z),
                +Math.cos(zeta) * Math.cos(theta) * Math.sin(z)
                        + Math.sin(zeta) * Math.cos(z),
                -Math.sin(zeta) * Math.cos(theta) * Math.sin(z)
                        + Math.cos(zeta) * Math.cos(z),
                -Math.sin(theta) * Math.sin(z),
                +Math.cos(zeta) * Math.sin(theta),
                -Math.sin(zeta) * Math.sin(theta),
                +Math.cos(theta)
        };

        outTriplet[0] = mat[0] * inTriplet[0]
                + mat[1] * inTriplet[1]
                + mat[2] * inTriplet[2];
        outTriplet[1] = mat[3] * inTriplet[0]
                + mat[4] * inTriplet[1]
                + mat[5] * inTriplet[2];
        outTriplet[2] = mat[6] * inTriplet[0]
                + mat[7] * inTriplet[1]
                + mat[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Convert equinox of date RA/Dec to ecliptic coordinates.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>The matrix to transform from RA/Dec to ecliptic is
     * <p/>
     * <p><table>
     * <tr align="center">
     * <td>M =</td>
     * <td>(<br>(<br>(</td>
     * <td>1<br>0<br>0</td>
     * <td>0<br>cos(&epsilon;)<br>
     * -sin(&epsilon;)</td>
     * <td>0<br>sin(&epsilon;)<br>
     * cos(&epsilon;)</td>
     * <td>)<br>)<br>)</td>
     * </tr>
     * </table>
     *
     * @param aEquinox  The equinox to which the given coordinates refer, also the time for
     *                  which the obliquity of the ecliptic needs to be calculated.
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertMeanToEcliptic(JulianTime aEquinox, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double eps;

        eps = obliquity(aEquinox);

        double mat[] = {
                1., 0., 0.,
                0., Math.cos(eps), Math.sin(eps),
                0., -Math.sin(eps), Math.cos(eps)
        };

        outTriplet[0] = mat[0] * inTriplet[0]
                + mat[1] * inTriplet[1]
                + mat[2] * inTriplet[2];
        outTriplet[1] = mat[3] * inTriplet[0]
                + mat[4] * inTriplet[1]
                + mat[5] * inTriplet[2];
        outTriplet[2] = mat[6] * inTriplet[0]
                + mat[7] * inTriplet[1]
                + mat[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Convert equinox of date to J2000 coordinates.
     * <p/>
     * <p>See also {@link #convertJ2000ToMean convertJ2000ToMean}.
     */

    public final static double[] convertMeanToJ2000(JulianTime aEquinox, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double t, zeta, z, theta;

        t = (aEquinox.getJulianEpoch() - 2000.) / 100.;
        zeta = .6406161 * t + 8.39e-5 * t * t
                + 5e-6 * t * t * t;
        z = .6406161 * t + 3.041e-4 * t * t
                + 5.1e-6 * t * t * t;
        theta = .556753 * t - 1.185e-4 * t * t
                - 1.16e-5 * t * t * t;
        zeta /= MiscellaneousUtils.DEGREES_PER_RADIAN;
        z /= MiscellaneousUtils.DEGREES_PER_RADIAN;
        theta /= MiscellaneousUtils.DEGREES_PER_RADIAN;

        double mat[] = {
                +Math.cos(zeta) * Math.cos(theta) * Math.cos(z)
                        - Math.sin(zeta) * Math.sin(z),
                -Math.sin(zeta) * Math.cos(theta) * Math.cos(z)
                        - Math.cos(zeta) * Math.sin(z),
                -Math.sin(theta) * Math.cos(z),
                +Math.cos(zeta) * Math.cos(theta) * Math.sin(z)
                        + Math.sin(zeta) * Math.cos(z),
                -Math.sin(zeta) * Math.cos(theta) * Math.sin(z)
                        + Math.cos(zeta) * Math.cos(z),
                -Math.sin(theta) * Math.sin(z),
                +Math.cos(zeta) * Math.sin(theta),
                -Math.sin(zeta) * Math.sin(theta),
                +Math.cos(theta)
        };

        outTriplet[0] = mat[0] * inTriplet[0]
                + mat[3] * inTriplet[1]
                + mat[6] * inTriplet[2];
        outTriplet[1] = mat[1] * inTriplet[0]
                + mat[4] * inTriplet[1]
                + mat[7] * inTriplet[2];
        outTriplet[2] = mat[2] * inTriplet[0]
                + mat[5] * inTriplet[1]
                + mat[8] * inTriplet[2];

        return outTriplet;

    }

    /**
     * Convert geocentric RA/Dec to topocentric HA/Dec.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>The transform is
     * <p/>
     * <p><table>
     * <tr align="center">
     * <td>(<br>(<br>(</td>
     * <td>x'<br>y'<br>z'</td>
     * <td>)<br>)<br>)</td>
     * <td>=</td>
     * <td>-</td>
     * <td>(<br>(<br>(</td>
     * <td>itsX<br>0<br>itsZ</td>
     * <td>)<br>)<br>)</td>
     * <td>+</td>
     * <td>(<br>(<br>(</td>
     * <td>cos(LST)<br>sin(LST)<br>0</td>
     * <td>sin(LST)<br>-cos(LST)<br>0</td>
     * <td>0<br>0<br>1</td>
     * <td>)<br>)<br>)</td>
     * <td>(<br>(<br>(</td>
     * <td>x<br>y<br>z</td>
     * <td>)<br>)<br>)</td>
     * </tr>
     * </table>
     * <p/>
     * <p>The matrix here includes an inversion of the topocentric y' axis.
     * While the geocentric y axis points towards Orion, the topocentric y' axis
     * points to the West point on the horizon.  Therefore
     * RA&nbsp;=&nbsp;atan(y/x) counts direct (counter-clockwise), but
     * HA&nbsp;=&nbsp;atan(y'/x') counts retrograde (clockwise).
     *
     * @param aStation  The time and location of the observatory.  There is an assumption that
     *                  the given geocentric coordinates are mean RA/Dec for the equinox of the
     *                  same date as the station clock shows.
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertMeanToTopocentric(EarthStation aStation, JulianTime time, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double theLST;
        double mat[] = new double[4];
        double vec[] = new double[3];

        theLST = aStation.getLocalSideralTime(time).getJulianDay() * Math.PI / 12.;
        mat[0] = Math.cos(theLST);
        mat[1] = Math.sin(theLST);
        mat[2] = Math.sin(theLST);
        mat[3] = -Math.cos(theLST);

        vec = aStation.getX0Z();

        outTriplet[0] = inTriplet[0] * mat[0]
                + inTriplet[1] * mat[1] - vec[0];
        outTriplet[1] = inTriplet[0] * mat[2]
                + inTriplet[1] * mat[3];
        outTriplet[2] = inTriplet[2] - vec[2];

        return outTriplet;

    }

    /**
     * Obliquity of the ecliptic.
     * <p/>
     * <p>We use the expression from
     * Jean Meeus, 1991, <em>Astronomical Algorithms</em>, Willmann-Bell, Richmond VA, p.135:
     * <p/>
     * <p>U = (Ep - 2000) / 10000
     * <p>&epsilon;
     * = 23&deg; + 26'
     * + (21.448
     * - 4680.93 U
     * -    1.55 U<sup>2</sup>
     * + 1999.25 U<sup>3</sup>
     * -   51.38 U<sup>4</sup>
     * <br>-  249.67 U<sup>5</sup>
     * -   39.05 U<sup>6</sup>
     * +    7.12 U<sup>7</sup>
     * +   27.87 U<sup>8</sup>
     * +    5.79 U<sup>9</sup>
     * +    2.45 U<sup>10</sup>)"
     *
     * @param aTime The time for which the obliquity (w.r.t. the equator and equinox of
     *              date) is required.
     */
    public final static double obliquity(JulianTime aTime) {

        double theTime;
        double theEps;

        /* Obtain the time in units of 10000 Julian years from J2000.0. */

        theTime = (aTime.getJulianEpoch() - 2000.) / 10000.;

        /* Use equation 21.3 of Meeus, 1991. */

        theEps = theTime * 2.45;
        theEps = theTime * (5.79 + theEps);
        theEps = theTime * (27.87 + theEps);
        theEps = theTime * (7.12 + theEps);
        theEps = theTime * (-39.05 + theEps);
        theEps = theTime * (-249.67 + theEps);
        theEps = theTime * (-51.38 + theEps);
        theEps = theTime * (1999.25 + theEps);
        theEps = theTime * (-1.55 + theEps);
        theEps = theTime * (-4680.93 + theEps);
        theEps += 21.448;
        theEps = 26. + theEps / 60.;
        theEps = 23. + theEps / 60.;
        theEps /= MiscellaneousUtils.DEGREES_PER_RADIAN;

        return theEps;

    }

    /**
     * Set the B1950 rectangular coordinates.
     * <p/>
     * <p>This sets the position stored from the given B1950/FK4 coordinates.
     * Conversion to J2000 for internal storage is performed.
     *
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.
     */
    public final void setB1950(double aTriplet[]) {

        coords = convertB1950ToJ2000(aTriplet);

    }

    /**
     * Set the mean equinox-of-date ecliptic rectangular coordinates.
     * <p/>
     * <p>This sets the position stored from the given mean ecliptic coordinates.
     * Conversion to J2000 for internal storage is performed.
     *
     * @param aEquinox The equinox to which the given coordinates refer, also the time for
     *                 which the obliquity of the ecliptic needs to be calculated.
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.
     */
    public final void setEcliptic(JulianTime aEquinox, double aTriplet[]) {

        coords = convertEclipticToMean(aEquinox, aTriplet);
        coords = convertMeanToJ2000(aEquinox, coords);

    }

    /**
     * Set the galactic rectangular coordinates.
     * <p/>
     * <p>This sets one stored position from the given galactic coordinates.
     * Conversion to J2000 for internal storage is performed.
     *
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.
     */
    public final void setGalactic(double aTriplet[]) {

        coords = convertGalacticToB1950(aTriplet);
        coords = convertB1950ToJ2000(coords);

    }

    /**
     * Set the horizontal rectangular coordinates.
     * <p/>
     * <p>This sets the position stored from the given horizontal coordinates.
     * Conversion to J2000 for internal storage is performed.
     *
     * @param aStation The time and location of the observatory.  The station clock is also
     *                 the date of the equinox.
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.  Note that the coordinates are
     *                 left-handed and that azimuth counts from North, i.e. the x axis points
     *                 to the North point and the y axis points to the East point on the
     *                 horizon.
     */
    public final void setHorizontal(EarthStation aStation, JulianTime time, double aTriplet[]) {

        coords = convertHorizontalToTopocentric(aStation, aTriplet);
        coords = convertTopocentricToMean(aStation, time, coords);
        coords = convertMeanToJ2000(time, coords);
    }

    /**
     * Set the J2000 rectangular coordinates.
     * <p/>
     * <p>This sets the position stored from the given J2000/FK5 coordinates.
     *
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.
     */

    public final void setJ2000(double aTriplet[]) {

        for (int i = 0; i < 3; i++) {
            coords[i] = aTriplet[i];
        }

    }

    /**
     * Set the mean equinox-of-date rectangular coordinates.
     * <p/>
     * <p>This sets the position stored from the given mean coordinates for the
     * equinox of date.  The date of the equinox also needs to be given.
     * Conversion to J2000 for internal storage is performed.
     *
     * @param aEquinox The equinox to which the given coordinates refer.
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.
     */
    public final void setMean(JulianTime aEquinox, double aTriplet[]) {

        coords = convertMeanToJ2000(aEquinox, aTriplet);

    }

    /**
     * Set the topocentric HA/Dec rectangular coordinates.
     * <p/>
     * <p>This sets the position stored from the given topocentric coordinates.
     * Conversion to J2000 for internal storage is performed.
     *
     * @param aStation The time and location of the observatory.  The station clock is also
     *                 the date of the equinox.
     * @param aTriplet Three floating point numbers containing the x, y and z coordinates.
     *                 These should normally be in Gm.  Note that the coordinates are
     *                 left-handed, i.e. the y axis points to the West point on the horizon.
     */
    public final void setTopocentric(EarthStation aStation, JulianTime time, double aTriplet[]) {

        coords = convertTopocentricToMean(aStation, time, aTriplet);
        coords = convertMeanToJ2000(time, coords);

    }

    /**
     * Convert HA/Dec to azimuth and elevation.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>The transform is
     * <p/>
     * <p><table>
     * <tr align="center">
     * <td>(<br>(<br>(</td>
     * <td>x"<br>y"<br>z"</td>
     * <td>)<br>)<br>)</td>
     * <td>=</td>
     * <td>(<br>(<br>(</td>
     * <td>-sin(&phi;)<br>0<br>cos(&phi;)</td>
     * <td>0<br>-1<br>0</td>
     * <td>cos(&phi;)<br>0<br>sin(&phi;)</td>
     * <td>)<br>)<br>)</td>
     * <td>(<br>(<br>(</td>
     * <td>x'<br>y'<br>z'</td>
     * <td>)<br>)<br>)</td>
     * </tr>
     * </table>
     * <p/>
     * <p>The matrix here includes an inversion of the x and y axes, which
     * amounts to a rotation by 180 degrees about the z axis.  This takes account
     * of the fact that azimuth counts from North while hour angle counts from
     * South.  Both count retrograde (clockwise).
     *
     * @param aStation  The location of the observatory.
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertTopocentricToHorizontal(EarthStation aStation, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double mat[] = new double[4];
        double theLat;

        theLat = aStation.getLatitude();

        mat[0] = -Math.sin(theLat);
        mat[1] = Math.cos(theLat);
        mat[2] = Math.cos(theLat);
        mat[3] = Math.sin(theLat);

        outTriplet[0] = inTriplet[0] * mat[0]
                + inTriplet[2] * mat[1];
        outTriplet[1] = -inTriplet[1];
        outTriplet[2] = inTriplet[0] * mat[2]
                + inTriplet[2] * mat[3];

        return outTriplet;

    }

    /**
     * Convert topocentric HA/Dec to geocentric RA/Dec.
     * <p/>
     * <p>This method does not change the state, it merely operates on aNpos
     * given triplets to generate aNpos returned triplets.
     * <p/>
     * <p>The transform is
     * <p/>
     * <p><table>
     * <tr align="center">
     * <td>(<br>(<br>(</td>
     * <td>x<br>y<br>z</td>
     * <td>)<br>)<br>)</td>
     * <td>=</td>
     * <td>(<br>(<br>(</td>
     * <td>cos(LST)<br>sin(LST)<br>0</td>
     * <td>sin(LST)<br>-cos(LST)<br>0</td>
     * <td>0<br>0<br>1</td>
     * <td>)<br>)<br>)</td>
     * <td>(<br>(<br>(</td>
     * <td>x' + itsX<br>y'<br>z' + itsZ</td>
     * <td>)<br>)<br>)</td>
     * </tr>
     * </table>
     * <p/>
     * <p>The matrix here includes an inversion of the topocentric y' axis.
     * While the geocentric y axis points towards Orion, the topocentric y' axis
     * points to the West point on the horizon.  Therefore
     * RA&nbsp;=&nbsp;atan(y/x) counts direct (counter-clockwise), but
     * HA&nbsp;=&nbsp;atan(y'/x') counts retrograde (clockwise).
     *
     * @param aStation  The time and location of the observatory.  There is an assumption that
     *                  the given geocentric coordinates are mean RA/Dec for the equinox of the
     *                  same date as the station clock shows.
     * @param inTriplet Array of 3*aNpos given numbers, each group of three forming an xyz
     *                  position in Gm.
     * @return Array of 3*aNpos returned numbers, each group of three forming an xyz
     *         position in Gm.
     */
    public final static double[] convertTopocentricToMean(EarthStation aStation, JulianTime time, double inTriplet[]) {

        double[] outTriplet;

        outTriplet = new double[3];
        double theLST;
        double mat[] = new double[4];
        double vec[] = new double[3];

        /* Vector from geocentre to station,
 * i.e. the geocentric position of the station.
 * Since we already rotated the x axis into the meridian,
 * this affects only x and z. */

        vec = aStation.getX0Z();

        /* Right ascension is negated hour angle plus local sidereal time,
* this rotation affects only x and y.
* (The negated hour angle counts direct, hour angle counts retrograde.) */

        theLST = aStation.getLocalSideralTime(time).getJulianDay() * Math.PI / 12.;
        mat[0] = Math.cos(theLST);
        mat[1] = Math.sin(theLST);
        mat[2] = Math.sin(theLST);
        mat[3] = -Math.cos(theLST);

        /* Process. */

        outTriplet[0] = (vec[0] + inTriplet[0]) * mat[0]
                + inTriplet[1] * mat[1];
        outTriplet[1] = (vec[0] + inTriplet[0]) * mat[2]
                + inTriplet[1] * mat[3];
        outTriplet[2] = vec[2] + inTriplet[2];

        return outTriplet;

    }

}
