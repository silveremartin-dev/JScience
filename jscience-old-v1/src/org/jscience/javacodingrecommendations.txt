Java recommendations:
These are recommendations that should complement the standard recommendations (see http://java.sun.com/docs/codeconv/ or for something less official http://g.oswego.edu/dl/html/javaCodingStd.html and http://en.wikipedia.org/wiki/Design_pattern_(computer_science)). They came into my mind as a natural way of thinking about code practices after thousands of hours reading code from others through hundred projects. They are mostly useless for a java beginner and only complement existing standard java conventions. These are NOT design patterns but high level comments on existing code limitations.


Use standards:
Standards are usually produced by cautious effort of an expert community. You save time using them. Moreover you have many opportinuties to find compatible existing code that you don't have to redevelop yourself.

Provide XML support:
When designing always keep in mind you need a way to interact with your code as a user (with a GUI or a commmand line) and a way to save and retrive your data. XML is easy, readable, powerful. Although you can think of having a complete io package with your own file format, classes can manage each for themselves XML reading, parsing and saving with minimal visble overhead complexity on your API. Atoms, for example, can use an autoloaded periodic table elements. Methods like toXML(String filename), fromXML(String filename) could help you fill in default values for objects instances.

No public variables:
You should have "clean" objects that are like blackbox, and process flow of input. Objects should look like lego bricks you plug into one others. Use getters and setters instead, theyt are much more powerful.

Use getter and setters:
As there should be no public variable, there should be getters and setters. It is very useful for object self containment, error checking and overriding. Moreover, performance penality is quite low as it seems.

Have standalone objects:
All knowledge about an object should be available without reference to other objects. We, humans, are at ease thinking about Objects as bricks. If objects are not standards bricks with clear inputs and outputs (and hidden contents), you loose the power of objects. Factories, Processors, Generators are many common ways of avoiding a great mess of interleaved objects. When an object werves more than one purpose it should be borken into parts. Think about objects as real stuff: cars, tables, chairs. You should never end up with tablechairs or the like: objects are first class citizens. 

Make deep copies:
When cloning always try to deep copy the objects or provide another way to do so. Either way, you should always make clear if an object is self contained or not and switch to such a state when needed. This takes more memory and a longer execution time but this makes you object safe and portable. This is something you therefore just have to think about before starting the class design. This is a Java problem which arises from having arguments passed by reference (pointers to objects) not by value (object contents). Or use Ada.

Think synchronization:
Always have in mind that your code may be someday used in a parallel environment. Though you are not obliged to synchronize everything or twist yourself with this simple fact, you should evaluate good candidates for synchonization, especially parts that involve a lot of processing (and can be split into many parallel similar tasks running at the same time) or that will run concurrenlty in an heterogenous or distributed environment (the program will have many communicating sub entities or people exchanging with a common core component at the same time). If you have standalone and self contained objects you will be at ease. Providing possible rendez vous point is also good. Synchronization is always a difficult problem but you can minimize its consequences if you think it can happen.

Think readability:
Usually, people have a problem with documentation. It is much better in Java than in any other language but still. Having complete Javadoc comments is very cool. If you can afford it, this is really a must for an API. If you can't you should still comment you code out. Think as a book writer designing a story and fill the gaps of the story with some comments ("we can optimize this", "this portion is really fast", "we could also check for null"...). This shorts comments will give you some insights about what the developer (may be you) had in mind when solving a problem and you will know more about code limitations, possible extensions and may be you will use this as a base for Javadoc generation later.

Think for others:
You never know how users will use your code and probably it will sometimes be used in very strange ways. You never can tell. You should therefore only concentrate on the things you really want to develop and put the rest as interfaces for future extensibility. If you keep the straight lines to the problem you want to solve you will at least solve these. Some others will someday come by and reuse or extend if it can. Just remember that all existing Java code was produced over the last ten years and this is an enormous amount. There are developers everywhere to continue where you stopped. Moreover, remember that there is not a single line of code that has ever survived more than 30 years.

Have a general case:
When designing your class, think about a general scenario in which users will fall. Imagine the methods the user will want and build around. Sometimes, the model becomes too complex and you will have to break it into a new design but cost will normally be minimal: the general scenario will still be the general scenario, you probably forgot its consequences, namely extensibility (which brings in turn more extensibility).

Internal can be ugly, noone cares:
Contrary to common belief, you don't have to build nice, perfect, school like code. The algorithms you use can be unreadable and absolute garbage. This makes no difference. What is important here is that the overall design, the one visible from the Javadoc is real good. Sometimes, it is really to difficult to have a nice algorithm or simply not reasonable if you want to debug it later. Though, the nice thing is still a comment or two.

Be a machine:
You have to beat the machine at its game. Your code should be designed in a rather automated way, with minimal brain and creativity. This means that if your classes all are similar and with no trick or trap you will have much more ease to produce and use them. This usually will make a little more classes in the beginning but finally a little less classes and a much more elegant code. Moreover, with a bit of luck you will find tools to automate code generation from templates. Yet, you shouldn't abuse using such things as users will think your code is ill designed if it looks like an over repetitive pattern lacking of a higher order abstraction (all the code could fall into one class).

No assumption about the code execution:
Don't believe users will be nice and won't try to use your code only for what you designed it for. You should therefore clearly comment what the expected inputs ranges of values are and that anything else will probably produce garbage. At least the users will then know that you were not thinking that far designing your code. You can also be restrictive, throwing everywhere an error when arguments are out of bounds (or null...). What I mean is that no one ever controls its code and you should never worry too much about what will happen outside the road you provide, but yet you should clearly have signs telling how to drive.

Use standard methods:
The equals, hashCode, clone are very ellegant and enhance your code. Users expect to find them. In a similar way, think about implementing standard interfaces (serialize...).

Use long names:
Methods and packages should only have complete english names: this is a bit longer but much more meaningful. You can always obfuscate code at a later stage to recover speed and memory.


A list of coding standards for Java
http://directory.google.com/Top/Computers/Programming/Languages/Java/Coding_Standards/



