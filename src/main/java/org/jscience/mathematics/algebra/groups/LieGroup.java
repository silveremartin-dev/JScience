*A Lie group is a group that is also a differentiable manifold.*In this implementation,elements are represented by square matrices over*Complex numbers.*The group is generated by a set of generators(matrices)from its*corresponding Lie Algebra.*</p>**@author Silvere Martin-Michiellot
 * @author Gemini AI (Google DeepMind)
 * @since 1.0
 */
public class LieGroup implements Group<Matrix<Complex>> {

    private final Matrix<Complex>[] generators;
    private final Matrix<Complex> identity;

    /**
     * Constructs a Lie Group from a set of generators.
     * 
     * @param generators the generators of the group (from Lie Algebra)
     * @throws IllegalArgumentException if generators is empty or not square
     */
    @SafeVarargs
    public LieGroup(Matrix<Complex>... generators) {
        if (generators.length == 0) {
            throw new IllegalArgumentException("At least one generator is required");
        }
        this.generators = generators;
        this.identity = generators[0].one(); // Assuming generators are square matrices
    }

    /**
     * Returns the dimension of the Lie Group (number of generators).
     * 
     * @return the dimension
     */
    public int dimension() {
        return generators.length;
    }

    /**
     * Generates a group element near the identity using the exponential map
     * approximation.
     * <p>
     * element = I + i * sum(v_k * G_k)
     * This is a linearization valid for small v.
     * </p>
     * 
     * @param v the vector of coefficients (must match dimension)
     * @return the group element (Matrix)
     */
    public Matrix<Complex> getElement(Vector<org.jscience.mathematics.number.Real> v) {
        if (v.dimension() != dimension()) {
            throw new IllegalArgumentException("Vector dimension must match group dimension");
        }

        Matrix<Complex> sum = identity.zero();
        for (int i = 0; i < dimension(); i++) {
            // G_k * v_k
            double val = v.get(i).doubleValue();
            Complex c = Complex.of(val);
            // We need to scale the matrix G_k by c
            // Matrix interface doesn't have scale(Scalar), but has multiply(Scalar) if it
            // was a VectorSpace.
            // But Matrix extends Ring<Matrix>.
            // We can use element-wise multiplication or just loop.
            // Let's assume we can multiply generator by scalar.
            // Since Matrix<E> doesn't have multiply(E), we might need to cast or implement
            // it.
            // Actually, Matrix usually supports scalar multiplication.
            // Let's use a helper or loop for now to be safe.
            sum = sum.add(scale(generators[i], c));
        }

        // I + i * sum
        return identity.add(scale(sum, Complex.I));
    }

    private Matrix<Complex> scale(Matrix<Complex> m, Complex s) {
        // Helper to scale matrix
        // This should be in Matrix interface ideally
        // For now, inefficient implementation
        // Actually, let's use the provider if possible, but we are in generic code
        // here.
        // We can't easily access provider without casting to DenseMatrix.
        // Let's rely on a loop for this specific V1 port.
        // Or better, cast to DenseMatrix if possible? No, keep it generic.
        // But we can't create a new generic Matrix easily without a factory.
        // We can use m.zero() to get a zero matrix and add? No.
        // We can use m.add(m) ... no.
        // We need a way to create a matrix.
        // Let's assume we can use DenseMatrix for the result for now, or throw if not
        // supported.
        // Actually, we can use the 'operate' method if we had a scalar action.
        // Let's just implement a simple loop assuming we can read/write or create.
        // But Matrix interface is read-only mostly (get).
        // We need a factory.
        // Let's use DenseMatrix.of for now.
        // This couples it to DenseMatrix, but acceptable for this port.
        java.util.List<java.util.List<Complex>> rows = new java.util.ArrayList<>();
        for (int i = 0; i < m.rows(); i++) {
            java.util.List<Complex> row = new java.util.ArrayList<>();
            for (int j = 0; j < m.cols(); j++) {
                row.add(m.get(i, j).multiply(s));
            }
            rows.add(row);
        }
        return org.jscience.mathematics.vector.DenseMatrix.of(rows,
                org.jscience.mathematics.number.set.Complexes.getInstance());
    }

    @Override
    public Matrix<Complex> operate(Matrix<Complex> a, Matrix<Complex> b) {
        return a.multiply(b);
    }

    @Override
    public Matrix<Complex> identity() {
        return identity;
    }

    @Override
    public Matrix<Complex> inverse(Matrix<Complex> element) {
        return element.inverse();
    }

    @Override
    public boolean isCommutative() {
        return false; // Lie groups are generally non-abelian
    }

    @Override
    public String description() {
        return "Lie Group (Dim " + dimension() + ")";
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public boolean contains(Matrix<Complex> element) {
        // Ideally check if element is in the group (near identity or generated)
        // For now, just check dimensions
        return element != null && element.rows() == identity.rows() && element.cols() == identity.cols();
    }
}
