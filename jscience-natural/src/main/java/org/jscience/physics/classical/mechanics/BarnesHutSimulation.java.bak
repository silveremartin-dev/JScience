/*
 * JScience - Java(TM) Tools and Libraries for the Advancement of Sciences.
 * Copyright (C) 2025 - Silvere Martin-Michiellot and Gemini AI (Google DeepMind)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package org.jscience.physics.classical.mechanics;

import org.jscience.mathematics.numbers.real.Real;
import org.jscience.mathematics.structures.SpatialOctree;
import org.jscience.physics.PhysicalConstants;

import java.util.ArrayList;
import java.util.List;

/**
 * Barnes-Hut N-body gravitational simulation (O(N log N)).
 * 
 * <p>
 * References:
 * <ul>
 * <li>Barnes, J., & Hut, P. (1986). A hierarchical O(N log N) force-calculation
 * algorithm. Nature, 324(6096), 446-449.</li>
 * </ul>
 * </p>
 *
 * @author Silvere Martin-Michiellot
 * @author Gemini AI (Google DeepMind)
 * @since 1.0
 */
public class BarnesHutSimulation {

    private final List<Particle> particles;
    private Real G = PhysicalConstants.G;
    private double theta = 0.5; // Accuracy parameter
    private double softening = 0.01;

    public BarnesHutSimulation() {
        this.particles = new ArrayList<>();
    }

    public void addParticle(Particle p) {
        particles.add(p);
    }

    public void step(Real dt) {
        // 1. Calculate boundaries
        double minX = Double.MAX_VALUE, minY = Double.MAX_VALUE, minZ = Double.MAX_VALUE;
        double maxX = Double.MIN_VALUE, maxY = Double.MIN_VALUE, maxZ = Double.MIN_VALUE;

        for (Particle p : particles) {
            minX = Math.min(minX, p.getX());
            maxX = Math.max(maxX, p.getX());
            minY = Math.min(minY, p.getY());
            maxY = Math.max(maxY, p.getY());
            minZ = Math.min(minZ, p.getZ());
            maxZ = Math.max(maxZ, p.getZ());
        }

        double size = Math.max(maxX - minX, Math.max(maxY - minY, maxZ - minZ));

        // 2. Build Octree
        SpatialOctree<Particle> tree = new SpatialOctree<>(minX, minY, minZ, size + 0.1);
        for (Particle p : particles) {
            tree.insert(p);
        }

        // 3. Compute Forces using Tree
        for (Particle p : particles) {
            p.setAcceleration(0, 0, 0);
            updateAcceleration(p, tree);
        }

        // 4. Update Positions/Velocities
        for (Particle p : particles) {
            p.updatePosition(dt);
            p.updateVelocity(dt);
        }
    }

    private void updateAcceleration(Particle p, SpatialOctree<Particle> node) {
        if (node.isLeaf()) {
            for (Particle other : node.getObjects()) {
                if (other != p) {
                    addForce(p, other.getX(), other.getY(), other.getZ(), other.getMassValue());
                }
            }
        } else {
            double dx = node.getCenterX() - p.getX();
            double dy = node.getCenterY() - p.getY();
            double dz = node.getCenterZ() - p.getZ();
            double r = Math.sqrt(dx * dx + dy * dy + dz * dz + softening * softening);

            if (node.getSize() / r < theta) {
                addForce(p, node.getCenterX(), node.getCenterY(), node.getCenterZ(), node.getTotalMass());
            } else {
                for (SpatialOctree<Particle> child : node.getChildren()) {
                    if (child != null)
                        updateAcceleration(p, child);
                }
            }
        }
    }

    private void addForce(Particle p, double x, double y, double z, double m) {
        double dx = x - p.getX();
        double dy = y - p.getY();
        double dz = z - p.getZ();
        double r2 = dx * dx + dy * dy + dz * dz + softening * softening;
        double r = Math.sqrt(r2);

        // F = G * m1 * m2 / r^2
        // a = G * m2 / r^3 * r_vec
        double factor = G.doubleValue() * m / (r2 * r);

        double ax = p.getAcceleration().get(0).doubleValue() + factor * dx;
        double ay = (p.getAcceleration().dimension() > 1) ? p.getAcceleration().get(1).doubleValue() + factor * dy : 0;
        double az = (p.getAcceleration().dimension() > 2) ? p.getAcceleration().get(2).doubleValue() + factor * dz : 0;

        p.setAcceleration(ax, ay, az);
    }
}
